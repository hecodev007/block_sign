// Go Substrate RPC Client (GSRPC) provides APIs and types around Polkadot and any Substrate-based chain RPC calls
//
// Copyright 2019 Centrifuge GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

// ExamplaryMetadataV9 is example metadata v9
var ExamplaryMetadataV9 = &Metadata{MagicNumber: 0x6174656d, Version: 0x9, AsMetadataV4: MetadataV4{Modules: []ModuleMetadataV4(nil)}, AsMetadataV7: MetadataV7{Modules: []ModuleMetadataV7(nil)}, AsMetadataV8: MetadataV8{Modules: []ModuleMetadataV8(nil)}, AsMetadataV9: MetadataV9{Modules: []ModuleMetadataV8{{Name: "System", HasStorage: true, Storage: StorageMetadata{Prefix: "System", Items: []StorageFunctionMetadataV5{{Name: "AccountNonce", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::Index", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Extrinsics nonce for accounts."}}, {Name: "ExtrinsicCount", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total extrinsics count for the current block."}}, {Name: "AllExtrinsicsWeight", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Weight", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total weight for all extrinsics put together, for the current block."}}, {Name: "AllExtrinsicsLen", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total length (in bytes) for all extrinsics put together, for the current block."}}, {Name: "BlockHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::BlockNumber", Value: "T::Hash", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Map of block numbers to block hashes."}}, {Name: "ExtrinsicData", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "u32", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Extrinsics data for the current block (maps an extrinsic's index to its data)."}}, {Name: "Number", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current block number being processed. Set by `execute_block`."}}, {Name: "ParentHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Hash of the previous block."}}, {Name: "ExtrinsicsRoot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Extrinsics root of the current block, also part of the block header."}}, {Name: "Digest", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "DigestOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Digest of the current block, also part of the block header."}}, {Name: "Events", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<EventRecord<T::Event, T::Hash>>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Events deposited for the current block."}}, {Name: "EventCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "EventIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of events in the `Events<T>` list."}}, {Name: "EventTopics", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "()", Key2: "T::Hash", Value: "Vec<(T::BlockNumber, EventIndex)>", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Mapping between a topic (represented by T::Hash) and a vector of indexes", " of events in the `<Events<T>>` list.", "", " The first key serves no purpose. This field is declared as double_map just", " for convenience of using `remove_prefix`.", "", " All topic vectors have deterministic storage locations depending on the topic. This", " allows light-clients to leverage the changes trie storage tracking mechanism and", " in case of changes fetch the list of events of interest.", "", " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just", " the `EventIndex` then in case if the topic has the same contents on the next block", " no notification will be triggered thus the event might be lost."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "fill_block", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" A big dispatch that will disallow any other transaction to be included."}}, {Name: "remark", Args: []FunctionArgumentMetadata{{Name: "_remark", Type: "Vec<u8>"}}, Documentation: []Text{" Make some on-chain remark."}}, {Name: "set_heap_pages", Args: []FunctionArgumentMetadata{{Name: "pages", Type: "u64"}}, Documentation: []Text{" Set the number of pages in the WebAssembly environment's heap."}}, {Name: "set_code", Args: []FunctionArgumentMetadata{{Name: "new", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new code."}}, {Name: "set_storage", Args: []FunctionArgumentMetadata{{Name: "items", Type: "Vec<KeyValue>"}}, Documentation: []Text{" Set some items of storage."}}, {Name: "kill_storage", Args: []FunctionArgumentMetadata{{Name: "keys", Type: "Vec<Key>"}}, Documentation: []Text{" Kill some items from storage."}}, {Name: "kill_prefix", Args: []FunctionArgumentMetadata{{Name: "prefix", Type: "Key"}}, Documentation: []Text{" Kill all storage items with a key that starts with the given prefix."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "ExtrinsicSuccess", Args: []Type{"DispatchInfo"}, Documentation: []Text{" An extrinsic completed successfully."}}, {Name: "ExtrinsicFailed", Args: []Type{"DispatchError", "DispatchInfo"}, Documentation: []Text{" An extrinsic failed."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Utility", HasStorage: false, Storage: StorageMetadata{Prefix: "", Items: []StorageFunctionMetadataV5(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "batch", Args: []FunctionArgumentMetadata{{Name: "calls", Type: "Vec<<T as Trait>::Call>"}}, Documentation: []Text{" Send a batch of dispatch calls (only root)."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "BatchExecuted", Args: []Type{"Vec<Result<(), DispatchError>>"}, Documentation: []Text(nil)}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Babe", HasStorage: true, Storage: StorageMetadata{Prefix: "Babe", Items: []StorageFunctionMetadataV5{{Name: "EpochIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current epoch index."}}, {Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(AuthorityId, BabeAuthorityWeight)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Current epoch authorities."}}, {Name: "GenesisSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The slot at which the first epoch actually started. This is 0", " until the first block of the chain."}}, {Name: "CurrentSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current slot number."}}, {Name: "Randomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "[u8; 32]", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The epoch randomness for the *current* epoch.", "", " # Security", "", " This MUST NOT be used for gambling, as it can be influenced by a", " malicious validator in the short term. It MAY be used in many", " cryptographic protocols, however, so long as one remembers that this", " (like everything else on-chain) it is public. For example, it can be", " used where a number is needed that cannot have been chosen by an", " adversary, for purposes such as public-coin zero-knowledge proofs."}}, {Name: "NextRandomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "[u8; 32]", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Next epoch randomness."}}, {Name: "SegmentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Randomness under construction.", "", " We make a tradeoff between storage accesses and list length.", " We store the under-construction randomness in segments of up to", " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.", "", " Once a segment reaches this length, we begin the next one.", " We reset all segments and return to `0` at the beginning of every", " epoch."}}, {Name: "UnderConstruction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "u32", Value: "Vec<[u8; 32]>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}, {Name: "Initialized", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "MaybeVrf", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Temporary value (cleared at block finalization) which is `Some`", " if per-block initialization has already been called for current block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{{Name: "EpochDuration", Type: "u64", Value: Bytes{0xc8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of **slots** that an epoch takes. We couple sessions to", " epochs, i.e. we start a new session once the new epoch begins."}}, {Name: "ExpectedBlockTime", Type: "T::Moment", Value: Bytes{0xb8, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The expected average block time at which BABE should be creating", " blocks. Since BABE is probabilistic it is not trivial to figure out", " what the expected average block time should be based on the slot", " duration and the security parameter `c` (where `1 - c` represents", " the probability of a slot being empty)."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Timestamp", HasStorage: true, Storage: StorageMetadata{Prefix: "Timestamp", Items: []StorageFunctionMetadataV5{{Name: "Now", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Moment", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current time for the current block."}}, {Name: "DidUpdate", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Did the timestamp get updated in this block?"}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set", Args: []FunctionArgumentMetadata{{Name: "now", Type: "Compact<T::Moment>"}}, Documentation: []Text{" Set the current time.", "", " This call should be invoked exactly once per block. It will panic at the finalization", " phase, if this call hasn't been invoked by that time.", "", " The timestamp should be greater than the previous one by the amount specified by", " `MinimumPeriod`.", "", " The dispatch origin for this call must be `Inherent`."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{{Name: "MinimumPeriod", Type: "T::Moment", Value: Bytes{0xdc, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum period between blocks. Beware that this is different to the *expected* period", " that the block production apparatus provides. Your chosen consensus system will generally", " work with this to determine a sensible block time. e.g. For Aura, it will be double this", " period on default settings."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Authorship", HasStorage: true, Storage: StorageMetadata{Prefix: "Authorship", Items: []StorageFunctionMetadataV5{{Name: "Uncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<UncleEntryItem<T::BlockNumber, T::Hash, T::AccountId>>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Uncles"}}, {Name: "Author", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Author of current block."}}, {Name: "DidSetUncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Whether uncles were already set in this block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_uncles", Args: []FunctionArgumentMetadata{{Name: "new_uncles", Type: "Vec<T::Header>"}}, Documentation: []Text{" Provide a set of uncles."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Indices", HasStorage: true, Storage: StorageMetadata{Prefix: "Indices", Items: []StorageFunctionMetadataV5{{Name: "NextEnumSet", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::AccountIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next free enumeration set."}}, {Name: "EnumSet", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountIndex", Value: "Vec<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The enumeration sets."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: true, Events: []EventMetadataV4{{Name: "NewAccountIndex", Args: []Type{"AccountId", "AccountIndex"}, Documentation: []Text{" A new account index was assigned.", "", " This event is not triggered when an existing index is reassigned", " to another `AccountId`."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Balances", HasStorage: true, Storage: StorageMetadata{Prefix: "Balances", Items: []StorageFunctionMetadataV5{{Name: "TotalIssuance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Balance", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total units issued in the system."}}, {Name: "Vesting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "VestingSchedule<T::Balance, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information regarding the vesting of a given account."}}, {Name: "FreeBalance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::Balance", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The 'free' balance of a given account.", "", " This is the only balance that matters in terms of most operations on tokens. It", " alone is used to determine the balance when in the contract execution environment. When this", " balance falls below the value of `ExistentialDeposit`, then the 'current account' is", " deleted: specifically `FreeBalance`. Further, the `OnFreeBalanceZero` callback", " is invoked, giving a chance to external modules to clean up data associated with", " the deleted account.", "", " `frame_system::AccountNonce` is also deleted if `ReservedBalance` is also zero (it also gets", " collapsed to zero if it ever becomes less than `ExistentialDeposit`."}}, {Name: "ReservedBalance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::Balance", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of the balance of a given account that is externally reserved; this can still get", " slashed, but gets slashed last of all.", "", " This balance is a 'reserve' balance that other subsystems use in order to set aside tokens", " that are still 'owned' by the account holder, but which are suspendable.", "", " When this balance falls below the value of `ExistentialDeposit`, then this 'reserve account'", " is deleted: specifically, `ReservedBalance`.", "", " `frame_system::AccountNonce` is also deleted if `FreeBalance` is also zero (it also gets", " collapsed to zero if it ever becomes less than `ExistentialDeposit`.)"}}, {Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<BalanceLock<T::Balance, T::BlockNumber>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any liquidity locks on some account balances."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "transfer", Args: []FunctionArgumentMetadata{{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Transfer some liquid free balance to another account.", "", " `transfer` will set the `FreeBalance` of the sender and receiver.", " It will decrease the total issuance of the system by the `TransferFee`.", " If the sender's account is below the existential deposit as a result", " of the transfer, the account will be reaped.", "", " The dispatch origin for this call must be `Signed` by the transactor.", "", " # <weight>", " - Dependent on arguments but not critical, given proper implementations for", "   input config  See related functions below.", " - It contains a limited number of reads and writes internally and no complex computation.", "", " Related functions:", "", "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.", "   - Transferring balances to accounts that did not exist before will cause", "      `T::OnNewAccount::on_new_account` to be called.", "   - Removing enough funds from an account will trigger", "     `T::DustRemoval::on_unbalanced` and `T::OnFreeBalanceZero::on_free_balance_zero`.", "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional", "     check that the transfer will not kill the origin account.", "", " # </weight>"}}, {Name: "set_balance", Args: []FunctionArgumentMetadata{{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "new_free", Type: "Compact<T::Balance>"}, {Name: "new_reserved", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Set the balances of a given account.", "", " This will alter `FreeBalance` and `ReservedBalance` in storage. it will", " also decrease the total issuance of the system (`TotalIssuance`).", " If the new free or reserved balance is below the existential deposit,", " it will reset the account nonce (`frame_system::AccountNonce`).", "", " The dispatch origin for this call is `root`.", "", " # <weight>", " - Independent of the arguments.", " - Contains a limited number of reads and writes.", " # </weight>"}}, {Name: "force_transfer", Args: []FunctionArgumentMetadata{{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Exactly as `transfer`, except the origin must be root and the source account may be", " specified."}}, {Name: "transfer_keep_alive", Args: []FunctionArgumentMetadata{{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Same as the [`transfer`] call, but with a check that the transfer will not kill the", " origin account.", "", " 99% of the time you want [`transfer`] instead.", "", " [`transfer`]: struct.Module.html#method.transfer"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NewAccount", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A new account was created."}}, {Name: "ReapedAccount", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account was reaped."}}, {Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance", "Balance"}, Documentation: []Text{" Transfer succeeded (from, to, value, fees)."}}, {Name: "BalanceSet", Args: []Type{"AccountId", "Balance", "Balance"}, Documentation: []Text{" A balance was set by root (who, free, reserved)."}}, {Name: "Deposit", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some amount was deposited (e.g. for transaction fees)."}}}, Constants: []ModuleConstantMetadataV6{{Name: "ExistentialDeposit", Type: "T::Balance", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to keep an account open."}}, {Name: "TransferFee", Type: "T::Balance", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to make a transfer."}}, {Name: "CreationFee", Type: "T::Balance", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to create an account."}}}, Errors: []ErrorMetadataV8{{Name: "VestingBalance", Documentation: []Text{" Vesting balance too high to send value"}}, {Name: "LiquidityRestrictions", Documentation: []Text{" Account liquidity restrictions prevent withdrawal"}}, {Name: "Overflow", Documentation: []Text{" Got an overflow after adding"}}, {Name: "InsufficientBalance", Documentation: []Text{" Balance too low to send value"}}, {Name: "ExistentialDeposit", Documentation: []Text{" Value too low to create account due to existential deposit"}}, {Name: "KeepAlive", Documentation: []Text{" Transfer/payment would kill account"}}, {Name: "ExistingVestingSchedule", Documentation: []Text{" A vesting schedule already exists for this account"}}, {Name: "DeadAccount", Documentation: []Text{" Beneficiary account must pre-exist"}}}}, {Name: "TransactionPayment", HasStorage: true, Storage: StorageMetadata{Prefix: "Balances", Items: []StorageFunctionMetadataV5{{Name: "NextFeeMultiplier", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Multiplier", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}}}, HasCalls: false, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{{Name: "TransactionBaseFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the base."}}, {Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Staking", HasStorage: true, Storage: StorageMetadata{Prefix: "Staking", Items: []StorageFunctionMetadataV5{{Name: "ValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ideal number of staking participants."}}, {Name: "MinimumValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x4, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum number of staking participants before emergency conditions are imposed."}}, {Name: "Invulnerables", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any validators that may never be slashed or forcibly kicked. It's a Vec since they're", " easy to initialize and the performance hit is minimal (we expect no more than four", " invulnerables) and restricted to testnets."}}, {Name: "Bonded", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all locked \"stash\" accounts to the controller account."}}, {Name: "Ledger", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "StakingLedger<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all (unlocked) \"controller\" accounts to the info regarding the staking."}}, {Name: "Payee", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "RewardDestination", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Where the reward payment should be made. Keyed by stash."}}, {Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "ValidatorPrefs", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from (wannabe) validator stash key to the preferences of that validator."}}, {Name: "Nominators", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Nominations<T::AccountId>", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from nominator stash key to the set of stash keys of all validators to nominate.", "", " NOTE: is private so that we can ensure upgraded before all typical accesses.", " Direct storage APIs can still bypass this protection."}}, {Name: "Stakers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Nominators for a particular account that is in action right now. You can't iterate", " through validators here, but you can find them in the Session module.", "", " This is keyed by the stash account."}}, {Name: "CurrentElected", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The currently elected validator set keyed by stash account ID."}}, {Name: "CurrentEra", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current era index."}}, {Name: "CurrentEraStart", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "MomentOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The start of the current era."}}, {Name: "CurrentEraStartSessionIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The session index at which the current era started."}}, {Name: "CurrentEraPointsEarned", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "EraPoints", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Rewards for the current era. Using indices of current elected set."}}, {Name: "SlotStake", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of balance actively at stake for each validator slot, currently.", "", " This is used to derive rewards and punishments."}}, {Name: "ForceEra", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Forcing", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the next session change will be a new era regardless of index."}}, {Name: "SlashRewardFraction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Perbill", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The percentage of the slash that is distributed to reporters.", "", " The rest of the slashed value is handled by the `Slash`."}}, {Name: "CanceledSlashPayout", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency given to reporters of a slash event which was", " canceled by extraordinary circumstances (e.g. governance)."}}, {Name: "UnappliedSlashes", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "EraIndex", Value: "Vec<UnappliedSlash<T::AccountId, BalanceOf<T>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All unapplied slashes that are queued for later."}}, {Name: "BondedEras", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(EraIndex, SessionIndex)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from still-bonded eras to the first session index of that era."}}, {Name: "ValidatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "(Perbill, BalanceOf<T>)", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: true, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on validators, mapped by era to the highest slash proportion", " and slash value of the era."}}, {Name: "NominatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "BalanceOf<T>", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: true, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on nominators, mapped by era to the highest slash value of the era."}}, {Name: "SlashingSpans", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "slashing::SlashingSpans", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Slashing spans for stash accounts."}}, {Name: "SpanSlash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "(T::AccountId, slashing::SpanIndex)", Value: "slashing::SpanRecord<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Records information about the maximum slash of a stash within a slashing span,", " as well as how much reward has been paid out."}}, {Name: "EarliestUnappliedSlash", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The earliest era for which we have a pending, unapplied slash."}}, {Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The version of storage for upgrade."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "bond", Args: []FunctionArgumentMetadata{{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}, {Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" Take the origin account as a stash and lock up `value` of its balance. `controller` will", " be the account that controls it.", "", " `value` must be more than the `minimum_balance` specified by `T::Currency`.", "", " The dispatch origin for this call must be _Signed_ by the stash account.", "", " # <weight>", " - Independent of the arguments. Moderate complexity.", " - O(1).", " - Three extra DB entries.", "", " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless", " the `origin` falls below _existential deposit_ and gets removed as dust.", " # </weight>"}}, {Name: "bond_extra", Args: []FunctionArgumentMetadata{{Name: "max_additional", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Add some extra amount that have appeared in the stash `free_balance` into the balance up", " for staking.", "", " Use this if there are additional funds in your stash account that you wish to bond.", " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount", " that can be added.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - O(1).", " - One DB entry.", " # </weight>"}}, {Name: "unbond", Args: []FunctionArgumentMetadata{{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Schedule a portion of the stash to be unlocked ready for transfer out after the bond", " period ends. If this leaves an amount actively bonded less than", " T::Currency::minimum_balance(), then it is increased to the full amount.", "", " Once the unlock period is done, you can call `withdraw_unbonded` to actually move", " the funds out of management ready for transfer.", "", " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)", " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need", " to be called first to remove some of the chunks (if possible).", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::withdraw_unbonded`].", "", " # <weight>", " - Independent of the arguments. Limited but potentially exploitable complexity.", " - Contains a limited number of reads.", " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)", "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.", "   The only way to clean the aforementioned storage item is also user-controlled via `withdraw_unbonded`.", " - One DB entry.", " </weight>"}}, {Name: "withdraw_unbonded", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove any unlocked chunks from the `unlocking` queue from our management.", "", " This essentially frees up that balance to be used by the stash account to do", " whatever it wants.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::unbond`].", "", " # <weight>", " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.", "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is", "  indirectly user-controlled. See [`unbond`] for more detail.", " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "validate", Args: []FunctionArgumentMetadata{{Name: "prefs", Type: "ValidatorPrefs"}}, Documentation: []Text{" Declare the desire to validate for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "nominate", Args: []FunctionArgumentMetadata{{Name: "targets", Type: "Vec<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Declare the desire to nominate `targets` for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - The transaction's complexity is proportional to the size of `targets`,", " which is capped at `MAX_NOMINATIONS`.", " - Both the reads and writes follow a similar pattern.", " # </weight>"}}, {Name: "chill", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Declare no desire to either validate or nominate.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains one read.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "set_payee", Args: []FunctionArgumentMetadata{{Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" (Re-)set the payment target for a controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "set_controller", Args: []FunctionArgumentMetadata{{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" (Re-)set the controller of a stash.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "set_validator_count", Args: []FunctionArgumentMetadata{{Name: "new", Type: "Compact<u32>"}}, Documentation: []Text{" The ideal number of validators."}}, {Name: "force_no_eras", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be no new eras indefinitely.", "", " # <weight>", " - No arguments.", " # </weight>"}}, {Name: "force_new_era", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of the next session. After this, it will be", " reset to normal (non-forced) behaviour.", "", " # <weight>", " - No arguments.", " # </weight>"}}, {Name: "set_invulnerables", Args: []FunctionArgumentMetadata{{Name: "validators", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the validators who cannot be slashed (if any)."}}, {Name: "force_unstake", Args: []FunctionArgumentMetadata{{Name: "stash", Type: "T::AccountId"}}, Documentation: []Text{" Force a current staker to become completely unstaked, immediately."}}, {Name: "force_new_era_always", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of sessions indefinitely.", "", " # <weight>", " - One storage write", " # </weight>"}}, {Name: "cancel_deferred_slash", Args: []FunctionArgumentMetadata{{Name: "era", Type: "EraIndex"}, {Name: "slash_indices", Type: "Vec<u32>"}}, Documentation: []Text{" Cancel enactment of a deferred slash. Can be called by either the root origin or", " the `T::SlashCancelOrigin`.", " passing the era and indices of the slashes for that era to kill.", "", " # <weight>", " - One storage write.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Reward", Args: []Type{"Balance", "Balance"}, Documentation: []Text{" All validators have been rewarded by the first balance; the second is the remainder", " from the maximum amount of reward."}}, {Name: "Slash", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" One validator (and its nominators) has been slashed by the given amount."}}, {Name: "OldSlashingReportDiscarded", Args: []Type{"SessionIndex"}, Documentation: []Text{" An old slashing report from a prior era was discarded because it could", " not be processed."}}}, Constants: []ModuleConstantMetadataV6{{Name: "SessionsPerEra", Type: "SessionIndex", Value: Bytes{0x6, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of sessions per era."}}, {Name: "BondingDuration", Type: "EraIndex", Value: Bytes{0xa0, 0x2, 0x0, 0x0}, Documentation: []Text{" Number of eras that staked funds must remain bonded for."}}}, Errors: []ErrorMetadataV8{{Name: "NotController", Documentation: []Text{" Not a controller account."}}, {Name: "NotStash", Documentation: []Text{" Not a stash account."}}, {Name: "AlreadyBonded", Documentation: []Text{" Stash is already bonded."}}, {Name: "AlreadyPaired", Documentation: []Text{" Controller is already paired."}}, {Name: "EmptyTargets", Documentation: []Text{" Targets cannot be empty."}}, {Name: "DuplicateIndex", Documentation: []Text{" Duplicate index."}}, {Name: "InvalidSlashIndex", Documentation: []Text{" Slash record index out of bounds."}}, {Name: "InsufficientValue", Documentation: []Text{" Can not bond with value less than minimum balance."}}, {Name: "NoMoreChunks", Documentation: []Text{" Can not schedule more unlock chunks."}}}}, {Name: "Session", HasStorage: true, Storage: StorageMetadata{Prefix: "Session", Items: []StorageFunctionMetadataV5{{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::ValidatorId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of validators."}}, {Name: "CurrentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current index of the session."}}, {Name: "QueuedChanged", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the underlying economic identities or weighting behind the validators", " has changed in the queued validator set."}}, {Name: "QueuedKeys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(T::ValidatorId, T::Keys)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The queued keys for the next session. When the next session begins, these keys", " will be used to determine the validator's session keys."}}, {Name: "DisabledValidators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<u32>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Indices of disabled validators.", "", " The set is cleared when `on_session_ending` returns a new set of identities."}}, {Name: "NextKeys", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "Vec<u8>", Key2: "T::ValidatorId", Value: "T::Keys", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The next session keys for a validator.", "", " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of", " the trie. Having all data in the same branch should prevent slowing down other queries."}}, {Name: "KeyOwner", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "Vec<u8>", Key2: "(KeyTypeId, Vec<u8>)", Value: "T::ValidatorId", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The owner of a key. The second key is the `KeyTypeId` + the encoded key.", "", " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of", " the trie. Having all data in the same branch should prevent slowing down other queries."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_keys", Args: []FunctionArgumentMetadata{{Name: "keys", Type: "T::Keys"}, {Name: "proof", Type: "Vec<u8>"}}, Documentation: []Text{" Sets the session key(s) of the function caller to `key`.", " Allows an account to set its session key prior to becoming a validator.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - O(log n) in number of accounts.", " - One extra DB entry.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NewSession", Args: []Type{"SessionIndex"}, Documentation: []Text{" New session has happened. Note that the argument is the session index, not the block", " number as the type might suggest."}}}, Constants: []ModuleConstantMetadataV6{{Name: "DEDUP_KEY_PREFIX", Type: "&[u8]", Value: Bytes{0x34, 0x3a, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x6b, 0x65, 0x79, 0x73}, Documentation: []Text{" Used as first key for `NextKeys` and `KeyOwner` to put all the data into the same branch", " of the trie."}}}, Errors: []ErrorMetadataV8{{Name: "InvalidProof", Documentation: []Text{" Invalid ownership proof."}}, {Name: "NoAssociatedValidatorId", Documentation: []Text{" No associated validator ID for account."}}, {Name: "DuplicatedKey", Documentation: []Text{" Registered duplicate key."}}}}, {Name: "Democracy", HasStorage: true, Storage: StorageMetadata{Prefix: "Democracy", Items: []StorageFunctionMetadataV5{{Name: "PublicPropCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "PropIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of (public) proposals that have been made so far."}}, {Name: "PublicProps", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(PropIndex, T::Hash, T::AccountId)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The public proposals. Unsorted. The second item is the proposal's hash."}}, {Name: "Preimages", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "(Vec<u8>, T::AccountId, BalanceOf<T>, T::BlockNumber)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map of hashes to the proposal preimage, along with who registered it and their deposit.", " The block number is the block at which it was deposited."}}, {Name: "DepositOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "PropIndex", Value: "(BalanceOf<T>, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Those who have locked a deposit."}}, {Name: "ReferendumCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next free referendum index, aka the number of referenda started so far."}}, {Name: "LowestUnbaked", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The lowest referendum index representing an unbaked referendum. Equal to", " `ReferendumCount` if there isn't a unbaked referendum."}}, {Name: "ReferendumInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReferendumIndex", Value: "ReferendumInfo<T::BlockNumber, T::Hash>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information concerning any given referendum."}}, {Name: "DispatchQueue", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(T::BlockNumber, T::Hash, ReferendumIndex)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Queue of successful referenda to be dispatched. Stored ordered by block number."}}, {Name: "VotersFor", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReferendumIndex", Value: "Vec<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Get the voters for the current proposal."}}, {Name: "VoteOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "(ReferendumIndex, T::AccountId)", Value: "Vote", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Get the vote in a given referendum of a particular voter. The result is meaningful only", " if `voters_for` includes the voter when called with the referendum (you'll get the", " default `Vote` value otherwise). If you don't want to check `voters_for`, then you can", " also check for simple existence with `VoteOf::exists` first."}}, {Name: "Proxy", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Who is able to vote for whom. Value is the fund-holding account, key is the", " vote-transaction-sending account."}}, {Name: "Delegations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(T::AccountId, Conviction)", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Get the account (and lock periods) to which another account is delegating vote."}}, {Name: "LastTabledWasExternal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the last referendum tabled was submitted externally. False if it was a public", " proposal."}}, {Name: "NextExternal", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "(T::Hash, VoteThreshold)", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The referendum to be tabled whenever it would be valid to table an external proposal.", " This happens when a referendum needs to be tabled and one of two conditions are met:", " - `LastTabledWasExternal` is `false`; or", " - `PublicProps` is empty."}}, {Name: "Blacklist", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "(T::BlockNumber, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A record of who vetoed what. Maps proposal hash to a possible existent block number", " (until when it may not be resubmitted) and who vetoed it."}}, {Name: "Cancellations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Record of all proposals that have been subject to emergency cancellation."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "propose", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " # <weight>", " - O(1).", " - Two DB changes, one DB entry.", " # </weight>"}}, {Name: "second", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Compact<PropIndex>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " # <weight>", " - O(1).", " - One DB entry.", " # </weight>"}}, {Name: "vote", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, {Name: "vote", Type: "Vote"}}, Documentation: []Text{" Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;", " otherwise it is a vote to keep the status quo.", "", " # <weight>", " - O(1).", " - One DB change, one DB entry.", " # </weight>"}}, {Name: "proxy_vote", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, {Name: "vote", Type: "Vote"}}, Documentation: []Text{" Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact", " the proposal;  otherwise it is a vote to keep the status quo.", "", " # <weight>", " - O(1).", " - One DB change, one DB entry.", " # </weight>"}}, {Name: "emergency_cancel", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "ReferendumIndex"}}, Documentation: []Text{" Schedule an emergency cancellation of a referendum. Cannot happen twice to the same", " referendum."}}, {Name: "external_propose", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a referendum to be tabled once it is legal to schedule an external", " referendum."}}, {Name: "external_propose_majority", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a majority-carries referendum to be tabled next once it is legal to schedule", " an external referendum.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call."}}, {Name: "external_propose_default", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a negative-turnout-bias referendum to be tabled next once it is legal to", " schedule an external referendum.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call."}}, {Name: "fast_track", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}, {Name: "voting_period", Type: "T::BlockNumber"}, {Name: "delay", Type: "T::BlockNumber"}}, Documentation: []Text{" Schedule the currently externally-proposed majority-carries referendum to be tabled", " immediately. If there is no externally-proposed referendum currently, or if there is one", " but it is not a majority-carries referendum then it fails.", "", " - `proposal_hash`: The hash of the current external proposal.", " - `voting_period`: The period that is allowed for voting on this proposal. Increased to", "   `EmergencyVotingPeriod` if too low.", " - `delay`: The number of block after voting has ended in approval and this should be", "   enacted. This doesn't have a minimum amount."}}, {Name: "veto_external", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Veto and blacklist the external proposal hash."}}, {Name: "cancel_referendum", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "Compact<ReferendumIndex>"}}, Documentation: []Text{" Remove a referendum."}}, {Name: "cancel_queued", Args: []FunctionArgumentMetadata{{Name: "which", Type: "ReferendumIndex"}}, Documentation: []Text{" Cancel a proposal queued for enactment."}}, {Name: "set_proxy", Args: []FunctionArgumentMetadata{{Name: "proxy", Type: "T::AccountId"}}, Documentation: []Text{" Specify a proxy. Called by the stash.", "", " # <weight>", " - One extra DB entry.", " # </weight>"}}, {Name: "resign_proxy", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clear the proxy. Called by the proxy.", "", " # <weight>", " - One DB clear.", " # </weight>"}}, {Name: "remove_proxy", Args: []FunctionArgumentMetadata{{Name: "proxy", Type: "T::AccountId"}}, Documentation: []Text{" Clear the proxy. Called by the stash.", "", " # <weight>", " - One DB clear.", " # </weight>"}}, {Name: "delegate", Args: []FunctionArgumentMetadata{{Name: "to", Type: "T::AccountId"}, {Name: "conviction", Type: "Conviction"}}, Documentation: []Text{" Delegate vote.", "", " # <weight>", " - One extra DB entry.", " # </weight>"}}, {Name: "undelegate", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Undelegate vote.", "", " # <weight>", " - O(1).", " # </weight>"}}, {Name: "clear_public_proposals", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Veto and blacklist the proposal hash. Must be from Root origin."}}, {Name: "note_preimage", Args: []FunctionArgumentMetadata{{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This doesn't require the proposal to be", " in the dispatch queue but does require a deposit, returned once enacted."}}, {Name: "note_imminent_preimage", Args: []FunctionArgumentMetadata{{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This requires the proposal to be", " in the dispatch queue. No deposit is needed."}}, {Name: "reap_preimage", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Remove an expired proposal preimage and collect the deposit.", "", " This will only work after `VotingPeriod` blocks from the time that the preimage was", " noted, if it's the same account doing it. If it's a different account, then it'll only", " work an additional `EnactmentPeriod` later."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"PropIndex", "Balance"}, Documentation: []Text{" A motion has been proposed by a public account."}}, {Name: "Tabled", Args: []Type{"PropIndex", "Balance", "Vec<AccountId>"}, Documentation: []Text{" A public proposal has been tabled for referendum vote."}}, {Name: "ExternalTabled", Args: []Type(nil), Documentation: []Text{" An external proposal has been tabled."}}, {Name: "Started", Args: []Type{"ReferendumIndex", "VoteThreshold"}, Documentation: []Text{" A referendum has begun."}}, {Name: "Passed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been approved by referendum."}}, {Name: "NotPassed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been rejected by referendum."}}, {Name: "Cancelled", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A referendum has been cancelled."}}, {Name: "Executed", Args: []Type{"ReferendumIndex", "bool"}, Documentation: []Text{" A proposal has been enacted."}}, {Name: "Delegated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" An account has delegated their vote to another account."}}, {Name: "Undelegated", Args: []Type{"AccountId"}, Documentation: []Text{" An account has cancelled a previous delegation operation."}}, {Name: "Vetoed", Args: []Type{"AccountId", "Hash", "BlockNumber"}, Documentation: []Text{" An external proposal has been vetoed."}}, {Name: "PreimageNoted", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal's preimage was noted, and the deposit taken."}}, {Name: "PreimageUsed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal preimage was removed and used (the deposit was returned)."}}, {Name: "PreimageInvalid", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was invalid."}}, {Name: "PreimageMissing", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was missing."}}, {Name: "PreimageReaped", Args: []Type{"Hash", "AccountId", "Balance", "AccountId"}, Documentation: []Text{" A registered preimage was removed and the deposit collected by the reaper (last item)."}}}, Constants: []ModuleConstantMetadataV6{{Name: "EnactmentPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x2f, 0xd, 0x0}, Documentation: []Text{" The minimum period of locking and the period between a proposal being approved and enacted.", "", " It should generally be a little more than the unstake period to ensure that", " voting stakers have an opportunity to remove themselves from the system in the case where", " they are on the losing side of a vote."}}, {Name: "LaunchPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) new public referenda are launched."}}, {Name: "VotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) to check for new votes."}}, {Name: "MinimumDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount to be used as a deposit for a public referendum proposal."}}, {Name: "EmergencyVotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x51, 0x1, 0x0}, Documentation: []Text{" Minimum voting period allowed for an emergency referendum."}}, {Name: "CooloffPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" Period in blocks where an external proposal may not be re-submitted after being vetoed."}}, {Name: "PreimageByteDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of balance that must be deposited per byte of preimage stored."}}}, Errors: []ErrorMetadataV8{{Name: "ValueLow", Documentation: []Text{" Value too low"}}, {Name: "ProposalMissing", Documentation: []Text{" Proposal does not exist"}}, {Name: "NotProxy", Documentation: []Text{" Not a proxy"}}, {Name: "BadIndex", Documentation: []Text{" Unknown index"}}, {Name: "AlreadyCanceled", Documentation: []Text{" Cannot cancel the same proposal twice"}}, {Name: "DuplicateProposal", Documentation: []Text{" Proposal already made"}}, {Name: "ProposalBlacklisted", Documentation: []Text{" Proposal still blacklisted"}}, {Name: "NotSimpleMajority", Documentation: []Text{" Next external proposal not simple majority"}}, {Name: "InvalidHash", Documentation: []Text{" Invalid hash"}}, {Name: "NoProposal", Documentation: []Text{" No external proposal"}}, {Name: "AlreadyVetoed", Documentation: []Text{" Identity may not veto a proposal twice"}}, {Name: "AlreadyProxy", Documentation: []Text{" Already a proxy"}}, {Name: "WrongProxy", Documentation: []Text{" Wrong proxy"}}, {Name: "NotDelegated", Documentation: []Text{" Not delegated"}}, {Name: "DuplicatePreimage", Documentation: []Text{" Preimage already noted"}}, {Name: "NotImminent", Documentation: []Text{" Not imminent"}}, {Name: "Early", Documentation: []Text{" Too early"}}, {Name: "Imminent", Documentation: []Text{" Imminent"}}, {Name: "PreimageMissing", Documentation: []Text{" Preimage not found"}}, {Name: "ReferendumInvalid", Documentation: []Text{" Vote given for invalid referendum"}}, {Name: "PreimageInvalid", Documentation: []Text{" Invalid preimage"}}, {Name: "NoneWaiting", Documentation: []Text{" No proposals waiting"}}}}, {Name: "Council", HasStorage: true, Storage: StorageMetadata{Prefix: "Instance1Collective", Items: []StorageFunctionMetadataV5{{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, {Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, {Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Votes<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, {Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, {Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_members", Args: []FunctionArgumentMetadata{{Name: "new_members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the collective's membership manually to `new_members`. Be nice to the chain and", " provide it pre-sorted.", "", " Requires root origin."}}, {Name: "execute", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective."}}, {Name: "propose", Args: []FunctionArgumentMetadata{{Name: "threshold", Type: "Compact<MemberCount>"}, {Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" # <weight>", " - Bounded storage reads and writes.", " - Argument `threshold` has bearing on weight.", " # </weight>"}}, {Name: "vote", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "T::Hash"}, {Name: "index", Type: "Compact<ProposalIndex>"}, {Name: "approve", Type: "bool"}}, Documentation: []Text{" # <weight>", " - Bounded storage read and writes.", " - Will be slightly heavier if the proposal is approved / disapproved after the vote.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`)."}}, {Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`)."}}, {Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold."}}, {Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold."}}, {Name: "Executed", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A motion was executed; `bool` is true if returned without error."}}, {Name: "MemberExecuted", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A single member did some action; `bool` is true if returned without error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, {Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, {Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, {Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, {Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, {Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}}}, {Name: "TechnicalCommittee", HasStorage: true, Storage: StorageMetadata{Prefix: "Instance2Collective", Items: []StorageFunctionMetadataV5{{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, {Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, {Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Votes<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, {Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, {Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_members", Args: []FunctionArgumentMetadata{{Name: "new_members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the collective's membership manually to `new_members`. Be nice to the chain and", " provide it pre-sorted.", "", " Requires root origin."}}, {Name: "execute", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective."}}, {Name: "propose", Args: []FunctionArgumentMetadata{{Name: "threshold", Type: "Compact<MemberCount>"}, {Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" # <weight>", " - Bounded storage reads and writes.", " - Argument `threshold` has bearing on weight.", " # </weight>"}}, {Name: "vote", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "T::Hash"}, {Name: "index", Type: "Compact<ProposalIndex>"}, {Name: "approve", Type: "bool"}}, Documentation: []Text{" # <weight>", " - Bounded storage read and writes.", " - Will be slightly heavier if the proposal is approved / disapproved after the vote.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`)."}}, {Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`)."}}, {Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold."}}, {Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold."}}, {Name: "Executed", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A motion was executed; `bool` is true if returned without error."}}, {Name: "MemberExecuted", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A single member did some action; `bool` is true if returned without error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, {Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, {Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, {Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, {Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, {Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}}}, {Name: "Elections", HasStorage: true, Storage: StorageMetadata{Prefix: "PhragmenElection", Items: []StorageFunctionMetadataV5{{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(T::AccountId, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current elected membership. Sorted based on account id."}}, {Name: "RunnersUp", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(T::AccountId, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current runners_up. Sorted based on low to high merit (worse to best runner)."}}, {Name: "ElectionRounds", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total number of vote rounds that have happened, excluding the upcoming one."}}, {Name: "VotesOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<T::AccountId>", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes of a particular voter, with the round index of the votes."}}, {Name: "StakeOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Locked stake of a voter."}}, {Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The present candidate list. Sorted based on account id. A current member can never enter", " this vector and is always implicitly assumed to be a candidate."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "vote", Args: []FunctionArgumentMetadata{{Name: "votes", Type: "Vec<T::AccountId>"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Vote for a set of candidates for the upcoming round of election.", "", " The `votes` should:", "   - not be empty.", "   - be less than the number of candidates.", "", " Upon voting, `value` units of `who`'s balance is locked and a bond amount is reserved.", " It is the responsibility of the caller to not place all of their balance into the lock", " and keep some for further transactions.", "", " # <weight>", " #### State", " Reads: O(1)", " Writes: O(V) given `V` votes. V is bounded by 16.", " # </weight>"}}, {Name: "remove_voter", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove `origin` as a voter. This removes the lock and returns the bond.", "", " # <weight>", " #### State", " Reads: O(1)", " Writes: O(1)", " # </weight>"}}, {Name: "report_defunct_voter", Args: []FunctionArgumentMetadata{{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Report `target` for being an defunct voter. In case of a valid report, the reporter is", " rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and", " their bond is slashed.", "", " A defunct voter is defined to be:", "   - a voter whose current submitted votes are all invalid. i.e. all of them are no", "     longer a candidate nor an active member.", "", " # <weight>", " #### State", " Reads: O(NLogM) given M current candidates and N votes for `target`.", " Writes: O(1)", " # </weight>"}}, {Name: "submit_candidacy", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Submit oneself for candidacy.", "", " A candidate will either:", "   - Lose at the end of the term and forfeit their deposit.", "   - Win and become a member. Members will eventually get their stash back.", "   - Become a runner-up. Runners-ups are reserved members in case one gets forcefully", "     removed.", "", " # <weight>", " #### State", " Reads: O(LogN) Given N candidates.", " Writes: O(1)", " # </weight>"}}, {Name: "renounce_candidacy", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Renounce one's intention to be a candidate for the next election round. 3 potential", " outcomes exist:", " - `origin` is a candidate and not elected in any set. In this case, the bond is", "   unreserved, returned and origin is removed as a candidate.", " - `origin` is a current runner up. In this case, the bond is unreserved, returned and", "   origin is removed as a runner.", " - `origin` is a current member. In this case, the bond is unreserved and origin is", "   removed as a member, consequently not being a candidate for the next round anymore.", "   Similar to [`remove_voter`], if replacement runners exists, they are immediately used."}}, {Name: "remove_member", Args: []FunctionArgumentMetadata{{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove a particular member from the set. This is effective immediately and the bond of", " the outgoing member is slashed.", "", " If a runner-up is available, then the best runner-up will be removed and replaces the", " outgoing member. Otherwise, a new phragmen round is started.", "", " Note that this does not affect the designated block number of the next election.", "", " # <weight>", " #### State", " Reads: O(do_phragmen)", " Writes: O(do_phragmen)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NewTerm", Args: []Type{"Vec<(AccountId, Balance)>"}, Documentation: []Text{" A new term with new members. This indicates that enough candidates existed, not that", " enough have has been elected. The inner value must be examined for this purpose."}}, {Name: "EmptyTerm", Args: []Type(nil), Documentation: []Text{" No (or not enough) candidates existed for this round."}}, {Name: "MemberKicked", Args: []Type{"AccountId"}, Documentation: []Text{" A member has been removed. This should always be followed by either `NewTerm` ot", " `EmptyTerm`."}}, {Name: "MemberRenounced", Args: []Type{"AccountId"}, Documentation: []Text{" A member has renounced their candidacy."}}, {Name: "VoterReported", Args: []Type{"AccountId", "AccountId", "bool"}, Documentation: []Text{" A voter (first element) was reported (byt the second element) with the the report being", " successful or not (third element)."}}}, Constants: []ModuleConstantMetadataV6{{Name: "CandidacyBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, {Name: "VotingBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, {Name: "DesiredMembers", Type: "u32", Value: Bytes{0xd, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, {Name: "DesiredRunnersUp", Type: "u32", Value: Bytes{0x7, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, {Name: "TermDuration", Type: "T::BlockNumber", Value: Bytes{0x80, 0x13, 0x3, 0x0}, Documentation: []Text(nil)}}, Errors: []ErrorMetadataV8(nil)}, {Name: "TechnicalMembership", HasStorage: true, Storage: StorageMetadata{Prefix: "Instance1Membership", Items: []StorageFunctionMetadataV5{{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current membership, stored as an ordered Vec."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "add_member", Args: []FunctionArgumentMetadata{{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Add a member `who` to the set.", "", " May only be called from `AddOrigin` or root."}}, {Name: "remove_member", Args: []FunctionArgumentMetadata{{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Remove a member `who` from the set.", "", " May only be called from `RemoveOrigin` or root."}}, {Name: "swap_member", Args: []FunctionArgumentMetadata{{Name: "remove", Type: "T::AccountId"}, {Name: "add", Type: "T::AccountId"}}, Documentation: []Text{" Swap out one member `remove` for another `add`.", "", " May only be called from `SwapOrigin` or root."}}, {Name: "reset_members", Args: []FunctionArgumentMetadata{{Name: "members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Change the membership to a new set, disregarding the existing membership. Be nice and", " pass `members` pre-sorted.", "", " May only be called from `ResetOrigin` or root."}}, {Name: "change_key", Args: []FunctionArgumentMetadata{{Name: "new", Type: "T::AccountId"}}, Documentation: []Text{" Swap out the sending member for some other key `new`.", "", " May only be called from `Signed` origin of a current member."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "MemberAdded", Args: []Type(nil), Documentation: []Text{" The given member was added; see the transaction for who."}}, {Name: "MemberRemoved", Args: []Type(nil), Documentation: []Text{" The given member was removed; see the transaction for who."}}, {Name: "MembersSwapped", Args: []Type(nil), Documentation: []Text{" Two members were swapped; see the transaction for who."}}, {Name: "MembersReset", Args: []Type(nil), Documentation: []Text{" The membership was reset; see the transaction for who the new set is."}}, {Name: "KeyChanged", Args: []Type(nil), Documentation: []Text{" One of the members' keys changed."}}, {Name: "Dummy", Args: []Type{"sp_std::marker::PhantomData<(AccountId, Event)>"}, Documentation: []Text{" Phantom member, never used."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "FinalityTracker", HasStorage: false, Storage: StorageMetadata{Prefix: "", Items: []StorageFunctionMetadataV5(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "final_hint", Args: []FunctionArgumentMetadata{{Name: "hint", Type: "Compact<T::BlockNumber>"}}, Documentation: []Text{" Hint that the author of this block thinks the best finalized", " block is the given number."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{{Name: "WindowSize", Type: "T::BlockNumber", Value: Bytes{0x65, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of recent samples to keep from this chain. Default is 101."}}, {Name: "ReportLatency", Type: "T::BlockNumber", Value: Bytes{0xe8, 0x3, 0x0, 0x0}, Documentation: []Text{" The delay after which point things become suspicious. Default is 1000."}}}, Errors: []ErrorMetadataV8{{Name: "AlreadyUpdated", Documentation: []Text{" Final hint must be updated only once in the block"}}, {Name: "BadHint", Documentation: []Text{" Finalized height above block number"}}}}, {Name: "Grandpa", HasStorage: true, Storage: StorageMetadata{Prefix: "GrandpaFinality", Items: []StorageFunctionMetadataV5{{Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "AuthorityList", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" DEPRECATED", "", " This used to store the current authority set, which has been migrated to the well-known", " GRANDPA_AUTHORITES_KEY unhashed key."}}, {Name: "State", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "StoredState<T::BlockNumber>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" State of the current authority set."}}, {Name: "PendingChange", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "StoredPendingChange<T::BlockNumber>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending change: (signaled at, scheduled change)."}}, {Name: "NextForced", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" next block number where we can force a change."}}, {Name: "Stalled", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "(T::BlockNumber, T::BlockNumber)", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" `true` if we are currently stalled."}}, {Name: "CurrentSetId", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SetId", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of changes (both in terms of keys and underlying economic responsibilities)", " in the \"set\" of Grandpa validators from genesis."}}, {Name: "SetIdSession", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "SetId", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from grandpa set ID to the index of the *most recent* session for which its members were responsible."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "report_misbehavior", Args: []FunctionArgumentMetadata{{Name: "_report", Type: "Vec<u8>"}}, Documentation: []Text{" Report some misbehavior."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NewAuthorities", Args: []Type{"AuthorityList"}, Documentation: []Text{" New authority set has been applied."}}, {Name: "Paused", Args: []Type(nil), Documentation: []Text{" Current authority set has been paused."}}, {Name: "Resumed", Args: []Type(nil), Documentation: []Text{" Current authority set has been resumed."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{{Name: "PauseFailed", Documentation: []Text{" Attempt to signal GRANDPA pause when the authority set isn't live", " (either paused or already pending pause)."}}, {Name: "ResumeFailed", Documentation: []Text{" Attempt to signal GRANDPA resume when the authority set isn't paused", " (either live or already pending resume)."}}, {Name: "ChangePending", Documentation: []Text{" Attempt to signal GRANDPA change with one already pending."}}, {Name: "TooSoon", Documentation: []Text{" Cannot signal forced change so soon after last."}}}}, {Name: "Treasury", HasStorage: true, Storage: StorageMetadata{Prefix: "Treasury", Items: []StorageFunctionMetadataV5{{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "ProposalIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of proposals that have been made."}}, {Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ProposalIndex", Value: "Proposal<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposals that have been made."}}, {Name: "Approvals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<ProposalIndex>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposal indices that have been approved but not yet awarded."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "propose_spend", Args: []FunctionArgumentMetadata{{Name: "value", Type: "Compact<BalanceOf<T>>"}, {Name: "beneficiary", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Put forward a suggestion for spending. A deposit proportional to the value", " is reserved and slashed if the proposal is rejected. It is returned once the", " proposal is awarded.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change, one extra DB entry.", " # </weight>"}}, {Name: "reject_proposal", Args: []FunctionArgumentMetadata{{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Reject a proposed spend. The original deposit will be slashed.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB clear.", " # </weight>"}}, {Name: "approve_proposal", Args: []FunctionArgumentMetadata{{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Approve a proposal. At a later time, the proposal will be allocated to the beneficiary", " and the original deposit will be returned.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"ProposalIndex"}, Documentation: []Text{" New proposal."}}, {Name: "Spending", Args: []Type{"Balance"}, Documentation: []Text{" We have ended a spend period and will now allocate funds."}}, {Name: "Awarded", Args: []Type{"ProposalIndex", "Balance", "AccountId"}, Documentation: []Text{" Some funds have been allocated."}}, {Name: "Rejected", Args: []Type{"ProposalIndex", "Balance"}, Documentation: []Text{" A proposal was rejected; funds were slashed."}}, {Name: "Burnt", Args: []Type{"Balance"}, Documentation: []Text{" Some of our funds have been burnt."}}, {Name: "Rollover", Args: []Type{"Balance"}, Documentation: []Text{" Spending has finished; this is the amount that rolls over until next spend."}}, {Name: "Deposit", Args: []Type{"Balance"}, Documentation: []Text{" Some funds have been deposited."}}}, Constants: []ModuleConstantMetadataV6{{Name: "ProposalBond", Type: "Permill", Value: Bytes{0x50, 0xc3, 0x0, 0x0}, Documentation: []Text{" Fraction of a proposal's value that should be bonded in order to place the proposal.", " An accepted proposal gets these back. A rejected proposal does not."}}, {Name: "ProposalBondMinimum", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum amount of funds that should be placed in a deposit for making a proposal."}}, {Name: "SpendPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" Period between successive spends."}}, {Name: "Burn", Type: "Permill", Value: Bytes{0x20, 0xa1, 0x7, 0x0}, Documentation: []Text{" Percentage of spare funds (if any) that are burnt per spend period."}}}, Errors: []ErrorMetadataV8{{Name: "InsufficientProposersBalance", Documentation: []Text{" Proposer's balance is too low."}}, {Name: "InvalidProposalIndex", Documentation: []Text{" No proposal at that index."}}}}, {Name: "Contracts", HasStorage: true, Storage: StorageMetadata{Prefix: "Contract", Items: []StorageFunctionMetadataV5{{Name: "GasSpent", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Gas", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Gas spent so far in this block."}}, {Name: "CurrentSchedule", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Schedule", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x87, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" Current cost schedule for contracts."}}, {Name: "PristineCode", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "CodeHash<T>", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from an original code hash to the original code, untouched by instrumentation."}}, {Name: "CodeStorage", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "CodeHash<T>", Value: "wasm::PrefabWasmModule", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping between an original code hash and instrumented wasm code, ready for execution."}}, {Name: "AccountCounter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The subtrie counter."}}, {Name: "ContractInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "ContractInfo<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The code associated with a given account."}}, {Name: "GasPrice", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The price of one unit of gas."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "update_schedule", Args: []FunctionArgumentMetadata{{Name: "schedule", Type: "Schedule"}}, Documentation: []Text{" Updates the schedule for metering contracts.", "", " The schedule must have a greater version than the stored schedule."}}, {Name: "put_code", Args: []FunctionArgumentMetadata{{Name: "gas_limit", Type: "Compact<Gas>"}, {Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Stores the given binary Wasm code into the chain's storage and returns its `codehash`.", " You can instantiate contracts only with stored code."}}, {Name: "call", Args: []FunctionArgumentMetadata{{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}, {Name: "gas_limit", Type: "Compact<Gas>"}, {Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Makes a call to an account, optionally transferring some balance.", "", " * If the account is a smart-contract account, the associated code will be", " executed and any value will be transferred.", " * If the account is a regular account, any value will be transferred.", " * If no account exists and the call value is not less than `existential_deposit`,", " a regular account will be created and any value will be transferred."}}, {Name: "instantiate", Args: []FunctionArgumentMetadata{{Name: "endowment", Type: "Compact<BalanceOf<T>>"}, {Name: "gas_limit", Type: "Compact<Gas>"}, {Name: "code_hash", Type: "CodeHash<T>"}, {Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Instantiates a new contract from the `codehash` generated by `put_code`, optionally transferring some balance.", "", " Instantiation is executed as follows:", "", " - The destination address is computed based on the sender and hash of the code.", " - The smart-contract account is created at the computed address.", " - The `ctor_code` is executed in the context of the newly-created account. Buffer returned", "   after the execution is saved as the `code` of the account. That code will be invoked", "   upon any call received by this account.", " - The contract is initialized."}}, {Name: "claim_surcharge", Args: []FunctionArgumentMetadata{{Name: "dest", Type: "T::AccountId"}, {Name: "aux_sender", Type: "Option<T::AccountId>"}}, Documentation: []Text{" Allows block producers to claim a small reward for evicting a contract. If a block producer", " fails to do so, a regular users will be allowed to claim the reward.", "", " If contract is not evicted as a result of this call, no actions are taken and", " the sender is not eligible for the reward."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" Transfer happened `from` to `to` with given `value` as part of a `call` or `instantiate`."}}, {Name: "Instantiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Contract deployed by address at the specified address."}}, {Name: "CodeStored", Args: []Type{"Hash"}, Documentation: []Text{" Code with the specified hash has been stored."}}, {Name: "ScheduleUpdated", Args: []Type{"u32"}, Documentation: []Text{" Triggered when the current schedule is updated."}}, {Name: "Dispatched", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A call was dispatched from the given account. The bool signals whether it was", " successful execution or not."}}, {Name: "Contract", Args: []Type{"AccountId", "Vec<u8>"}, Documentation: []Text{" An event from contract of account."}}}, Constants: []ModuleConstantMetadataV6{{Name: "SignedClaimHandicap", Type: "T::BlockNumber", Value: Bytes{0x2, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of block delay an extrinsic claim surcharge has.", "", " When claim surcharge is called by an extrinsic the rent is checked", " for current_block - delay"}}, {Name: "TombstoneDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to generate a tombstone."}}, {Name: "StorageSizeOffset", Type: "u32", Value: Bytes{0x8, 0x0, 0x0, 0x0}, Documentation: []Text{" Size of a contract at the time of instantiaion. This is a simple way to ensure that", " empty contracts eventually gets deleted."}}, {Name: "RentByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Price of a byte of storage per one block interval. Should be greater than 0."}}, {Name: "RentDepositOffset", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0x8a, 0x5d, 0x78, 0x45, 0x63, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of funds a contract should deposit in order to offset", " the cost of one byte.", "", " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,", " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.", " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,", " then it would pay 500 BU/day."}}, {Name: "SurchargeReward", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xa1, 0xa7, 0x6b, 0x4a, 0x35, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Reward that is received by the party whose touch has led", " to removal of a contract."}}, {Name: "TransferFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to make a transfer."}}, {Name: "CreationFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to create an account."}}, {Name: "TransactionBaseFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the base."}}, {Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}, {Name: "ContractFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to instantiate a contract instance. A reasonable default value", " is 21."}}, {Name: "CallBaseFee", Type: "Gas", Value: Bytes{0xe8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base fee charged for calling into a contract. A reasonable default", " value is 135."}}, {Name: "InstantiateBaseFee", Type: "Gas", Value: Bytes{0xe8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base fee charged for instantiating a contract. A reasonable default value", " is 175."}}, {Name: "MaxDepth", Type: "u32", Value: Bytes{0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum nesting level of a call/instantiate stack. A reasonable default", " value is 100."}}, {Name: "MaxValueSize", Type: "u32", Value: Bytes{0x0, 0x40, 0x0, 0x0}, Documentation: []Text{" The maximum size of a storage value in bytes. A reasonable default is 16 KiB."}}, {Name: "BlockGasLimit", Type: "Gas", Value: Bytes{0x80, 0x96, 0x98, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum amount of gas that could be expended per block. A reasonable", " default value is 10_000_000."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Sudo", HasStorage: true, Storage: StorageMetadata{Prefix: "Sudo", Items: []StorageFunctionMetadataV5{{Name: "Key", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The `AccountId` of the sudo key."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "sudo", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<T::Proposal>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Root` origin.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Unknown weight of derivative `proposal` execution.", " # </weight>"}}, {Name: "set_key", Args: []FunctionArgumentMetadata{{Name: "new", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}, {Name: "sudo_as", Args: []FunctionArgumentMetadata{{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "proposal", Type: "Box<T::Proposal>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Signed` origin from", " a given account.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Unknown weight of derivative `proposal` execution.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Sudid", Args: []Type{"bool"}, Documentation: []Text{" A sudo just took place."}}, {Name: "KeyChanged", Args: []Type{"AccountId"}, Documentation: []Text{" The sudoer just switched identity; the old key is supplied."}}, {Name: "SudoAsDone", Args: []Type{"bool"}, Documentation: []Text{" A sudo just took place."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{{Name: "RequireSudo", Documentation: []Text{" Sender must be the Sudo account"}}}}, {Name: "ImOnline", HasStorage: true, Storage: StorageMetadata{Prefix: "ImOnline", Items: []StorageFunctionMetadataV5{{Name: "GossipAt", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The block number when we should gossip."}}, {Name: "Keys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AuthorityId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of keys that may issue a heartbeat."}}, {Name: "ReceivedHeartbeats", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "SessionIndex", Key2: "AuthIndex", Value: "Vec<u8>", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" For each session index, we keep a mapping of `AuthIndex`", " to `offchain::OpaqueNetworkState`."}}, {Name: "AuthoredBlocks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "SessionIndex", Key2: "T::ValidatorId", Value: "u32", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" For each session index, we keep a mapping of `T::ValidatorId` to the", " number of blocks authored by the given authority."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "heartbeat", Args: []FunctionArgumentMetadata{{Name: "heartbeat", Type: "Heartbeat<T::BlockNumber>"}, {Name: "_signature", Type: "<T::AuthorityId as RuntimeAppPublic>::Signature"}}, Documentation: []Text(nil)}}, HasEvents: true, Events: []EventMetadataV4{{Name: "HeartbeatReceived", Args: []Type{"AuthorityId"}, Documentation: []Text{" A new heartbeat was received from `AuthorityId`"}}, {Name: "AllGood", Args: []Type(nil), Documentation: []Text{" At the end of the session, no offence was committed."}}, {Name: "SomeOffline", Args: []Type{"Vec<IdentificationTuple>"}, Documentation: []Text{" At the end of the session, at least once validator was found to be offline."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{{Name: "InvalidKey", Documentation: []Text{" Non existent public key."}}, {Name: "DuplicatedHeartbeat", Documentation: []Text{" Duplicated heartbeat."}}}}, {Name: "AuthorityDiscovery", HasStorage: false, Storage: StorageMetadata{Prefix: "", Items: []StorageFunctionMetadataV5(nil)}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Offences", HasStorage: true, Storage: StorageMetadata{Prefix: "Offences", Items: []StorageFunctionMetadataV5{{Name: "Reports", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReportIdOf<T>", Value: "OffenceDetails<T::AccountId, T::IdentificationTuple>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The primary structure that holds all offence records keyed by report identifiers."}}, {Name: "ConcurrentReportsIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "Kind", Key2: "OpaqueTimeSlot", Value: "Vec<ReportIdOf<T>>", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A vector of reports of the same kind that happened at the same time slot."}}, {Name: "ReportsByKindIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "Kind", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Enumerates all reports of a kind along with the time they happened.", "", " All reports are sorted by the time of offence.", "", " Note that the actual type of this mapping is `Vec<u8>`, this is because values of", " different types are not supported at the moment so we are doing the manual serialization."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: true, Events: []EventMetadataV4{{Name: "Offence", Args: []Type{"Kind", "OpaqueTimeSlot"}, Documentation: []Text{" There is an offence reported of the given `kind` happened at the `session_index` and", " (kind-specific) time slot. This event is not deposited for duplicate slashes."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "RandomnessCollectiveFlip", HasStorage: true, Storage: StorageMetadata{Prefix: "RandomnessCollectiveFlip", Items: []StorageFunctionMetadataV5{{Name: "RandomMaterial", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Series of block headers from the last 81 blocks that acts as random seed material. This", " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of", " the oldest hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Nicks", HasStorage: true, Storage: StorageMetadata{Prefix: "Sudo", Items: []StorageFunctionMetadataV5{{Name: "NameOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(Vec<u8>, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The lookup table for names."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_name", Args: []FunctionArgumentMetadata{{Name: "name", Type: "Vec<u8>"}}, Documentation: []Text{" Set an account's name. The name should be a UTF-8-encoded string by convention, though", " we don't check it.", "", " The name may not be more than `T::MaxLength` bytes, nor less than `T::MinLength` bytes.", "", " If the account doesn't already have a name, then a fee of `ReservationFee` is reserved", " in the account.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - At most one balance operation.", " - One storage read/write.", " - One event.", " # </weight>"}}, {Name: "clear_name", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clear an account's name and return the deposit. Fails if the account was not named.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - One balance operation.", " - One storage read/write.", " - One event.", " # </weight>"}}, {Name: "kill_name", Args: []FunctionArgumentMetadata{{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove an account's name and take charge of the deposit.", "", " Fails if `who` has not been named. The deposit is dealt with through `T::Slashed`", " imbalance handler.", "", " The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.", "", " # <weight>", " - O(1).", " - One unbalanced handler (probably a balance transfer)", " - One storage read/write.", " - One event.", " # </weight>"}}, {Name: "force_name", Args: []FunctionArgumentMetadata{{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "name", Type: "Vec<u8>"}}, Documentation: []Text{" Set a third-party account's name with no deposit.", "", " No length checking is done on the name.", "", " The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.", "", " # <weight>", " - O(1).", " - At most one balance operation.", " - One storage read/write.", " - One event.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NameSet", Args: []Type{"AccountId"}, Documentation: []Text{" A name was set."}}, {Name: "NameForced", Args: []Type{"AccountId"}, Documentation: []Text{" A name was forcibly set."}}, {Name: "NameChanged", Args: []Type{"AccountId"}, Documentation: []Text{" A name was changed."}}, {Name: "NameCleared", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was cleared, and the given balance returned."}}, {Name: "NameKilled", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was removed and the given balance slashed."}}}, Constants: []ModuleConstantMetadataV6{{Name: "ReservationFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Reservation fee."}}, {Name: "MinLength", Type: "u32", Value: Bytes{0x3, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum length a name may be."}}, {Name: "MaxLength", Type: "u32", Value: Bytes{0x10, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum length a name may be."}}}, Errors: []ErrorMetadataV8{{Name: "TooShort", Documentation: []Text{" A name is too short."}}, {Name: "TooLong", Documentation: []Text{" A name is too long."}}, {Name: "Unnamed", Documentation: []Text{" An account in't named."}}}}}}} //nolint:lll,dupl
