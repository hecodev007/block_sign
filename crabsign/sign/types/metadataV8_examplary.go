// Go Substrate RPC Client (GSRPC) provides APIs and types around Polkadot and any Substrate-based chain RPC calls
//
// Copyright 2019 Centrifuge GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

// ExamplaryMetadataV8 is example metadata v8
var ExamplaryMetadataV8 = &Metadata{MagicNumber: 0x6174656d, Version: 0x8, AsMetadataV4: MetadataV4{Modules: []ModuleMetadataV4(nil)}, AsMetadataV7: MetadataV7{Modules: []ModuleMetadataV7(nil)}, AsMetadataV8: MetadataV8{Modules: []ModuleMetadataV8{{Name: "System", HasStorage: true, Storage: StorageMetadata{Prefix: "System", Items: []StorageFunctionMetadataV5{{Name: "AccountNonce", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::Index", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Extrinsics nonce for accounts."}}, {Name: "ExtrinsicCount", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total extrinsics count for the current block."}}, {Name: "AllExtrinsicsWeight", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Weight", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total weight for all extrinsics put together, for the current block."}}, {Name: "AllExtrinsicsLen", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total length (in bytes) for all extrinsics put together, for the current block."}}, {Name: "NextWeightMultiplier", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "WeightMultiplier", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next weight multiplier. This should be updated at the end of each block based on the", " saturation level (weight)."}}, {Name: "BlockHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::BlockNumber", Value: "T::Hash", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Map of block numbers to block hashes."}}, {Name: "ExtrinsicData", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "u32", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Extrinsics data for the current block (maps an extrinsic's index to its data)."}}, {Name: "Number", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current block number being processed. Set by `execute_block`."}}, {Name: "ParentHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Hash of the previous block."}}, {Name: "ExtrinsicsRoot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Extrinsics root of the current block, also part of the block header."}}, {Name: "Digest", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "DigestOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Digest of the current block, also part of the block header."}}, {Name: "Events", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<EventRecord<T::Event, T::Hash>>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Events deposited for the current block."}}, {Name: "EventCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "EventIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of events in the `Events<T>` list."}}, {Name: "EventTopics", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "()", Key2: "T::Hash", Value: "Vec<(T::BlockNumber, EventIndex)>", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Mapping between a topic (represented by T::Hash) and a vector of indexes", " of events in the `<Events<T>>` list.", "", " The first key serves no purpose. This field is declared as double_map just", " for convenience of using `remove_prefix`.", "", " All topic vectors have deterministic storage locations depending on the topic. This", " allows light-clients to leverage the changes trie storage tracking mechanism and", " in case of changes fetch the list of events of interest.", "", " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just", " the `EventIndex` then in case if the topic has the same contents on the next block", " no notification will be triggered thus the event might be lost."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "fill_block", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" A big dispatch that will disallow any other transaction to be included."}}, {Name: "remark", Args: []FunctionArgumentMetadata{{Name: "_remark", Type: "Vec<u8>"}}, Documentation: []Text{" Make some on-chain remark."}}, {Name: "set_heap_pages", Args: []FunctionArgumentMetadata{{Name: "pages", Type: "u64"}}, Documentation: []Text{" Set the number of pages in the WebAssembly environment's heap."}}, {Name: "set_code", Args: []FunctionArgumentMetadata{{Name: "new", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new code."}}, {Name: "set_storage", Args: []FunctionArgumentMetadata{{Name: "items", Type: "Vec<KeyValue>"}}, Documentation: []Text{" Set some items of storage."}}, {Name: "kill_storage", Args: []FunctionArgumentMetadata{{Name: "keys", Type: "Vec<Key>"}}, Documentation: []Text{" Kill some items from storage."}}, {Name: "kill_prefix", Args: []FunctionArgumentMetadata{{Name: "prefix", Type: "Key"}}, Documentation: []Text{" Kill all storage items with a key that starts with the given prefix."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "ExtrinsicSuccess", Args: []Type(nil), Documentation: []Text{" An extrinsic completed successfully."}}, {Name: "ExtrinsicFailed", Args: []Type{"DispatchError"}, Documentation: []Text{" An extrinsic failed."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{{Name: "BadSignature", Documentation: []Text(nil)}, {Name: "BlockFull", Documentation: []Text(nil)}, {Name: "RequireSignedOrigin", Documentation: []Text(nil)}, {Name: "RequireRootOrigin", Documentation: []Text(nil)}, {Name: "RequireNoOrigin", Documentation: []Text(nil)}}}, {Name: "Utility", HasStorage: false, Storage: StorageMetadata{Prefix: "", Items: []StorageFunctionMetadataV5(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "batch", Args: []FunctionArgumentMetadata{{Name: "calls", Type: "Vec<<T as Trait>::Call>"}}, Documentation: []Text{" Send a batch of dispatch calls (only root)."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "BatchExecuted", Args: []Type{"Vec<Result<(), DispatchError>>"}, Documentation: []Text(nil)}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Babe", HasStorage: true, Storage: StorageMetadata{Prefix: "Babe", Items: []StorageFunctionMetadataV5{{Name: "EpochIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current epoch index."}}, {Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(AuthorityId, BabeAuthorityWeight)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Current epoch authorities."}}, {Name: "GenesisSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The slot at which the first epoch actually started. This is 0", " until the first block of the chain."}}, {Name: "CurrentSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current slot number."}}, {Name: "Randomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "[u8; 32]", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The epoch randomness for the *current* epoch.", "", " # Security", "", " This MUST NOT be used for gambling, as it can be influenced by a", " malicious validator in the short term. It MAY be used in many", " cryptographic protocols, however, so long as one remembers that this", " (like everything else on-chain) it is public. For example, it can be", " used where a number is needed that cannot have been chosen by an", " adversary, for purposes such as public-coin zero-knowledge proofs."}}, {Name: "NextRandomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "[u8; 32]", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Next epoch randomness."}}, {Name: "SegmentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Randomness under construction.", "", " We make a tradeoff between storage accesses and list length.", " We store the under-construction randomness in segments of up to", " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.", "", " Once a segment reaches this length, we begin the next one.", " We reset all segments and return to `0` at the beginning of every", " epoch."}}, {Name: "UnderConstruction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "u32", Value: "Vec<[u8; 32]>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}, {Name: "Initialized", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "MaybeVrf", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Temporary value (cleared at block finalization) which is `Some`", " if per-block initialization has already been called for current block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{{Name: "EpochDuration", Type: "u64", Value: Bytes{0xc8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of **slots** that an epoch takes. We couple sessions to", " epochs, i.e. we start a new session once the new epoch begins."}}, {Name: "ExpectedBlockTime", Type: "T::Moment", Value: Bytes{0xb8, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The expected average block time at which BABE should be creating", " blocks. Since BABE is probabilistic it is not trivial to figure out", " what the expected average block time should be based on the slot", " duration and the security parameter `c` (where `1 - c` represents", " the probability of a slot being empty)."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Timestamp", HasStorage: true, Storage: StorageMetadata{Prefix: "Timestamp", Items: []StorageFunctionMetadataV5{{Name: "Now", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Moment", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current time for the current block."}}, {Name: "DidUpdate", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Did the timestamp get updated in this block?"}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set", Args: []FunctionArgumentMetadata{{Name: "now", Type: "Compact<T::Moment>"}}, Documentation: []Text{" Set the current time.", "", " This call should be invoked exactly once per block. It will panic at the finalization", " phase, if this call hasn't been invoked by that time.", "", " The timestamp should be greater than the previous one by the amount specified by", " `MinimumPeriod`.", "", " The dispatch origin for this call must be `Inherent`."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{{Name: "MinimumPeriod", Type: "T::Moment", Value: Bytes{0xdc, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum period between blocks. Beware that this is different to the *expected* period", " that the block production apparatus provides. Your chosen consensus system will generally", " work with this to determine a sensible block time. e.g. For Aura, it will be double this", " period on default settings."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Authorship", HasStorage: true, Storage: StorageMetadata{Prefix: "Authorship", Items: []StorageFunctionMetadataV5{{Name: "Uncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<UncleEntryItem<T::BlockNumber, T::Hash, T::AccountId>>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Uncles"}}, {Name: "Author", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Author of current block."}}, {Name: "DidSetUncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Whether uncles were already set in this block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_uncles", Args: []FunctionArgumentMetadata{{Name: "new_uncles", Type: "Vec<T::Header>"}}, Documentation: []Text{" Provide a set of uncles."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Indices", HasStorage: true, Storage: StorageMetadata{Prefix: "Indices", Items: []StorageFunctionMetadataV5{{Name: "NextEnumSet", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::AccountIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next free enumeration set."}}, {Name: "EnumSet", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountIndex", Value: "Vec<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The enumeration sets."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: true, Events: []EventMetadataV4{{Name: "NewAccountIndex", Args: []Type{"AccountId", "AccountIndex"}, Documentation: []Text{" A new account index was assigned.", "", " This event is not triggered when an existing index is reassigned", " to another `AccountId`."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Balances", HasStorage: true, Storage: StorageMetadata{Prefix: "Balances", Items: []StorageFunctionMetadataV5{{Name: "TotalIssuance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::Balance", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total units issued in the system."}}, {Name: "Vesting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "VestingSchedule<T::Balance, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information regarding the vesting of a given account."}}, {Name: "FreeBalance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::Balance", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The 'free' balance of a given account.", "", " This is the only balance that matters in terms of most operations on tokens. It", " alone is used to determine the balance when in the contract execution environment. When this", " balance falls below the value of `ExistentialDeposit`, then the 'current account' is", " deleted: specifically `FreeBalance`. Further, the `OnFreeBalanceZero` callback", " is invoked, giving a chance to external modules to clean up data associated with", " the deleted account.", "", " `system::AccountNonce` is also deleted if `ReservedBalance` is also zero (it also gets", " collapsed to zero if it ever becomes less than `ExistentialDeposit`."}}, {Name: "ReservedBalance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::Balance", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of the balance of a given account that is externally reserved; this can still get", " slashed, but gets slashed last of all.", "", " This balance is a 'reserve' balance that other subsystems use in order to set aside tokens", " that are still 'owned' by the account holder, but which are suspendable.", "", " When this balance falls below the value of `ExistentialDeposit`, then this 'reserve account'", " is deleted: specifically, `ReservedBalance`.", "", " `system::AccountNonce` is also deleted if `FreeBalance` is also zero (it also gets", " collapsed to zero if it ever becomes less than `ExistentialDeposit`.)"}}, {Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<BalanceLock<T::Balance, T::BlockNumber>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any liquidity locks on some account balances."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "transfer", Args: []FunctionArgumentMetadata{{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Transfer some liquid free balance to another account.", "", " `transfer` will set the `FreeBalance` of the sender and receiver.", " It will decrease the total issuance of the system by the `TransferFee`.", " If the sender's account is below the existential deposit as a result", " of the transfer, the account will be reaped.", "", " The dispatch origin for this call must be `Signed` by the transactor.", "", " # <weight>", " - Dependent on arguments but not critical, given proper implementations for", "   input config  See related functions below.", " - It contains a limited number of reads and writes internally and no complex computation.", "", " Related functions:", "", "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.", "   - Transferring balances to accounts that did not exist before will cause", "      `T::OnNewAccount::on_new_account` to be called.", "   - Removing enough funds from an account will trigger", "     `T::DustRemoval::on_unbalanced` and `T::OnFreeBalanceZero::on_free_balance_zero`.", "", " # </weight>"}}, {Name: "set_balance", Args: []FunctionArgumentMetadata{{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "new_free", Type: "Compact<T::Balance>"}, {Name: "new_reserved", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Set the balances of a given account.", "", " This will alter `FreeBalance` and `ReservedBalance` in storage. it will", " also decrease the total issuance of the system (`TotalIssuance`).", " If the new free or reserved balance is below the existential deposit,", " it will reset the account nonce (`system::AccountNonce`).", "", " The dispatch origin for this call is `root`.", "", " # <weight>", " - Independent of the arguments.", " - Contains a limited number of reads and writes.", " # </weight>"}}, {Name: "force_transfer", Args: []FunctionArgumentMetadata{{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Exactly as `transfer`, except the origin must be root and the source account may be", " specified."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NewAccount", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A new account was created."}}, {Name: "ReapedAccount", Args: []Type{"AccountId"}, Documentation: []Text{" An account was reaped."}}, {Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance", "Balance"}, Documentation: []Text{" Transfer succeeded (from, to, value, fees)."}}}, Constants: []ModuleConstantMetadataV6{{Name: "ExistentialDeposit", Type: "T::Balance", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to keep an account open."}}, {Name: "TransferFee", Type: "T::Balance", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to make a transfer."}}, {Name: "CreationFee", Type: "T::Balance", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to create an account."}}, {Name: "TransactionBaseFee", Type: "T::Balance", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the base."}}, {Name: "TransactionByteFee", Type: "T::Balance", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Staking", HasStorage: true, Storage: StorageMetadata{Prefix: "Staking", Items: []StorageFunctionMetadataV5{{Name: "ValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ideal number of staking participants."}}, {Name: "MinimumValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x4, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum number of staking participants before emergency conditions are imposed."}}, {Name: "Invulnerables", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any validators that may never be slashed or forcibly kicked. It's a Vec since they're", " easy to initialize and the performance hit is minimal (we expect no more than four", " invulnerables) and restricted to testnets."}}, {Name: "Bonded", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all locked \"stash\" accounts to the controller account."}}, {Name: "Ledger", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "StakingLedger<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all (unlocked) \"controller\" accounts to the info regarding the staking."}}, {Name: "Payee", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "RewardDestination", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Where the reward payment should be made. Keyed by stash."}}, {Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "ValidatorPrefs<BalanceOf<T>>", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from (wannabe) validator stash key to the preferences of that validator."}}, {Name: "Nominators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Vec<T::AccountId>", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from nominator stash key to the set of stash keys of all validators to nominate."}}, {Name: "Stakers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Nominators for a particular account that is in action right now. You can't iterate", " through validators here, but you can find them in the Session module.", "", " This is keyed by the stash account."}}, {Name: "CurrentElected", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The currently elected validator set keyed by stash account ID."}}, {Name: "CurrentEra", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current era index."}}, {Name: "CurrentEraStart", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "MomentOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The start of the current era."}}, {Name: "CurrentEraStartSessionIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The session index at which the current era started."}}, {Name: "CurrentEraPointsEarned", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "EraPoints", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Rewards for the current era. Using indices of current elected set."}}, {Name: "SlotStake", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of balance actively at stake for each validator slot, currently.", "", " This is used to derive rewards and punishments."}}, {Name: "ForceEra", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Forcing", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the next session change will be a new era regardless of index."}}, {Name: "SlashRewardFraction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Perbill", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The percentage of the slash that is distributed to reporters.", "", " The rest of the slashed value is handled by the `Slash`."}}, {Name: "BondedEras", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(EraIndex, SessionIndex)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from still-bonded eras to the first session index of that era."}}, {Name: "EraSlashJournal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "EraIndex", Value: "Vec<SlashJournalEntry<T::AccountId, BalanceOf<T>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashes that have occurred in a given era."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "bond", Args: []FunctionArgumentMetadata{{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}, {Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" Take the origin account as a stash and lock up `value` of its balance. `controller` will", " be the account that controls it.", "", " `value` must be more than the `minimum_balance` specified by `T::Currency`.", "", " The dispatch origin for this call must be _Signed_ by the stash account.", "", " # <weight>", " - Independent of the arguments. Moderate complexity.", " - O(1).", " - Three extra DB entries.", "", " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless", " the `origin` falls below _existential deposit_ and gets removed as dust.", " # </weight>"}}, {Name: "bond_extra", Args: []FunctionArgumentMetadata{{Name: "max_additional", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Add some extra amount that have appeared in the stash `free_balance` into the balance up", " for staking.", "", " Use this if there are additional funds in your stash account that you wish to bond.", " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount", " that can be added.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - O(1).", " - One DB entry.", " # </weight>"}}, {Name: "unbond", Args: []FunctionArgumentMetadata{{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Schedule a portion of the stash to be unlocked ready for transfer out after the bond", " period ends. If this leaves an amount actively bonded less than", " T::Currency::minimum_balance(), then it is increased to the full amount.", "", " Once the unlock period is done, you can call `withdraw_unbonded` to actually move", " the funds out of management ready for transfer.", "", " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)", " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need", " to be called first to remove some of the chunks (if possible).", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::withdraw_unbonded`].", "", " # <weight>", " - Independent of the arguments. Limited but potentially exploitable complexity.", " - Contains a limited number of reads.", " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)", "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.", "   The only way to clean the aforementioned storage item is also user-controlled via `withdraw_unbonded`.", " - One DB entry.", " </weight>"}}, {Name: "withdraw_unbonded", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove any unlocked chunks from the `unlocking` queue from our management.", "", " This essentially frees up that balance to be used by the stash account to do", " whatever it wants.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::unbond`].", "", " # <weight>", " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.", "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is", "  indirectly user-controlled. See [`unbond`] for more detail.", " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "validate", Args: []FunctionArgumentMetadata{{Name: "prefs", Type: "ValidatorPrefs<BalanceOf<T>>"}}, Documentation: []Text{" Declare the desire to validate for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "nominate", Args: []FunctionArgumentMetadata{{Name: "targets", Type: "Vec<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Declare the desire to nominate `targets` for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - The transaction's complexity is proportional to the size of `targets`,", " which is capped at `MAX_NOMINATIONS`.", " - Both the reads and writes follow a similar pattern.", " # </weight>"}}, {Name: "chill", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Declare no desire to either validate or nominate.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains one read.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "set_payee", Args: []FunctionArgumentMetadata{{Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" (Re-)set the payment target for a controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "set_controller", Args: []FunctionArgumentMetadata{{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" (Re-)set the controller of a stash.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " # </weight>"}}, {Name: "set_validator_count", Args: []FunctionArgumentMetadata{{Name: "new", Type: "Compact<u32>"}}, Documentation: []Text{" The ideal number of validators."}}, {Name: "force_no_eras", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be no new eras indefinitely.", "", " # <weight>", " - No arguments.", " # </weight>"}}, {Name: "force_new_era", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of the next session. After this, it will be", " reset to normal (non-forced) behaviour.", "", " # <weight>", " - No arguments.", " # </weight>"}}, {Name: "set_invulnerables", Args: []FunctionArgumentMetadata{{Name: "validators", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the validators who cannot be slashed (if any)."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Reward", Args: []Type{"Balance"}, Documentation: []Text{" All validators have been rewarded by the given balance."}}, {Name: "Slash", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" One validator (and its nominators) has been slashed by the given amount."}}, {Name: "OldSlashingReportDiscarded", Args: []Type{"SessionIndex"}, Documentation: []Text{" An old slashing report from a prior era was discarded because it could", " not be processed."}}}, Constants: []ModuleConstantMetadataV6{{Name: "SessionsPerEra", Type: "SessionIndex", Value: Bytes{0x6, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of sessions per era."}}, {Name: "BondingDuration", Type: "EraIndex", Value: Bytes{0xa0, 0x2, 0x0, 0x0}, Documentation: []Text{" Number of eras that staked funds must remain bonded for."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Session", HasStorage: true, Storage: StorageMetadata{Prefix: "Session", Items: []StorageFunctionMetadataV5{{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::ValidatorId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of validators."}}, {Name: "CurrentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current index of the session."}}, {Name: "QueuedChanged", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the underlying economic identities or weighting behind the validators", " has changed in the queued validator set."}}, {Name: "QueuedKeys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(T::ValidatorId, T::Keys)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The queued keys for the next session. When the next session begins, these keys", " will be used to determine the validator's session keys."}}, {Name: "DisabledValidators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<u32>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Indices of disabled validators.", "", " The set is cleared when `on_session_ending` returns a new set of identities."}}, {Name: "NextKeys", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "Vec<u8>", Key2: "T::ValidatorId", Value: "T::Keys", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The next session keys for a validator.", "", " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of", " the trie. Having all data in the same branch should prevent slowing down other queries."}}, {Name: "KeyOwner", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true}, Key1: "Vec<u8>", Key2: "(KeyTypeId, Vec<u8>)", Value: "T::ValidatorId", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The owner of a key. The second key is the `KeyTypeId` + the encoded key.", "", " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of", " the trie. Having all data in the same branch should prevent slowing down other queries."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_keys", Args: []FunctionArgumentMetadata{{Name: "keys", Type: "T::Keys"}, {Name: "proof", Type: "Vec<u8>"}}, Documentation: []Text{" Sets the session key(s) of the function caller to `key`.", " Allows an account to set its session key prior to becoming a validator.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - O(log n) in number of accounts.", " - One extra DB entry.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NewSession", Args: []Type{"SessionIndex"}, Documentation: []Text{" New session has happened. Note that the argument is the session index, not the block", " number as the type might suggest."}}}, Constants: []ModuleConstantMetadataV6{{Name: "DEDUP_KEY_PREFIX", Type: "&[u8]", Value: Bytes{0x34, 0x3a, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x6b, 0x65, 0x79, 0x73}, Documentation: []Text{" Used as first key for `NextKeys` and `KeyOwner` to put all the data into the same branch", " of the trie."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Democracy", HasStorage: true, Storage: StorageMetadata{Prefix: "Democracy", Items: []StorageFunctionMetadataV5{{Name: "PublicPropCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "PropIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of (public) proposals that have been made so far."}}, {Name: "PublicProps", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(PropIndex, T::Proposal, T::AccountId)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The public proposals. Unsorted."}}, {Name: "DepositOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "PropIndex", Value: "(BalanceOf<T>, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Those who have locked a deposit."}}, {Name: "ReferendumCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next free referendum index, aka the number of referenda started so far."}}, {Name: "NextTally", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next referendum index that should be tallied."}}, {Name: "ReferendumInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReferendumIndex", Value: "(ReferendumInfo<T::BlockNumber, T::Proposal>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information concerning any given referendum."}}, {Name: "DispatchQueue", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::BlockNumber", Value: "Vec<Option<(T::Proposal, ReferendumIndex)>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Queue of successful referenda to be dispatched."}}, {Name: "VotersFor", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReferendumIndex", Value: "Vec<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Get the voters for the current proposal."}}, {Name: "VoteOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "(ReferendumIndex, T::AccountId)", Value: "Vote", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Get the vote in a given referendum of a particular voter. The result is meaningful only", " if `voters_for` includes the voter when called with the referendum (you'll get the", " default `Vote` value otherwise). If you don't want to check `voters_for`, then you can", " also check for simple existence with `VoteOf::exists` first."}}, {Name: "Proxy", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Who is able to vote for whom. Value is the fund-holding account, key is the", " vote-transaction-sending account."}}, {Name: "Delegations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(T::AccountId, Conviction)", Linked: true}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Get the account (and lock periods) to which another account is delegating vote."}}, {Name: "LastTabledWasExternal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the last referendum tabled was submitted externally. False if it was a public", " proposal."}}, {Name: "NextExternal", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "(T::Proposal, VoteThreshold)", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The referendum to be tabled whenever it would be valid to table an external proposal.", " This happens when a referendum needs to be tabled and one of two conditions are met:", " - `LastTabledWasExternal` is `false`; or", " - `PublicProps` is empty."}}, {Name: "Blacklist", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "(T::BlockNumber, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A record of who vetoed what. Maps proposal hash to a possible existent block number", " (until when it may not be resubmitted) and who vetoed it."}}, {Name: "Cancellations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Record of all proposals that have been subject to emergency cancellation."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "propose", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<T::Proposal>"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " # <weight>", " - O(1).", " - Two DB changes, one DB entry.", " # </weight>"}}, {Name: "second", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Compact<PropIndex>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " # <weight>", " - O(1).", " - One DB entry.", " # </weight>"}}, {Name: "vote", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, {Name: "vote", Type: "Vote"}}, Documentation: []Text{" Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;", " otherwise it is a vote to keep the status quo.", "", " # <weight>", " - O(1).", " - One DB change, one DB entry.", " # </weight>"}}, {Name: "proxy_vote", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, {Name: "vote", Type: "Vote"}}, Documentation: []Text{" Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact", " the proposal;  otherwise it is a vote to keep the status quo.", "", " # <weight>", " - O(1).", " - One DB change, one DB entry.", " # </weight>"}}, {Name: "emergency_cancel", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "ReferendumIndex"}}, Documentation: []Text{" Schedule an emergency cancellation of a referendum. Cannot happen twice to the same", " referendum."}}, {Name: "external_propose", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<T::Proposal>"}}, Documentation: []Text{" Schedule a referendum to be tabled once it is legal to schedule an external", " referendum."}}, {Name: "external_propose_majority", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<T::Proposal>"}}, Documentation: []Text{" Schedule a majority-carries referendum to be tabled next once it is legal to schedule", " an external referendum.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call."}}, {Name: "external_propose_default", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<T::Proposal>"}}, Documentation: []Text{" Schedule a negative-turnout-bias referendum to be tabled next once it is legal to", " schedule an external referendum.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call."}}, {Name: "fast_track", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}, {Name: "voting_period", Type: "T::BlockNumber"}, {Name: "delay", Type: "T::BlockNumber"}}, Documentation: []Text{" Schedule the currently externally-proposed majority-carries referendum to be tabled", " immediately. If there is no externally-proposed referendum currently, or if there is one", " but it is not a majority-carries referendum then it fails.", "", " - `proposal_hash`: The hash of the current external proposal.", " - `voting_period`: The period that is allowed for voting on this proposal.", " - `delay`: The number of block after voting has ended in approval and this should be", "   enacted. Increased to `EmergencyVotingPeriod` if too low."}}, {Name: "veto_external", Args: []FunctionArgumentMetadata{{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Veto and blacklist the external proposal hash."}}, {Name: "cancel_referendum", Args: []FunctionArgumentMetadata{{Name: "ref_index", Type: "Compact<ReferendumIndex>"}}, Documentation: []Text{" Remove a referendum."}}, {Name: "cancel_queued", Args: []FunctionArgumentMetadata{{Name: "when", Type: "Compact<T::BlockNumber>"}, {Name: "which", Type: "Compact<u32>"}, {Name: "what", Type: "Compact<ReferendumIndex>"}}, Documentation: []Text{" Cancel a proposal queued for enactment."}}, {Name: "set_proxy", Args: []FunctionArgumentMetadata{{Name: "proxy", Type: "T::AccountId"}}, Documentation: []Text{" Specify a proxy. Called by the stash.", "", " # <weight>", " - One extra DB entry.", " # </weight>"}}, {Name: "resign_proxy", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clear the proxy. Called by the proxy.", "", " # <weight>", " - One DB clear.", " # </weight>"}}, {Name: "remove_proxy", Args: []FunctionArgumentMetadata{{Name: "proxy", Type: "T::AccountId"}}, Documentation: []Text{" Clear the proxy. Called by the stash.", "", " # <weight>", " - One DB clear.", " # </weight>"}}, {Name: "delegate", Args: []FunctionArgumentMetadata{{Name: "to", Type: "T::AccountId"}, {Name: "conviction", Type: "Conviction"}}, Documentation: []Text{" Delegate vote.", "", " # <weight>", " - One extra DB entry.", " # </weight>"}}, {Name: "undelegate", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Undelegate vote.", "", " # <weight>", " - O(1).", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"PropIndex", "Balance"}, Documentation: []Text(nil)}, {Name: "Tabled", Args: []Type{"PropIndex", "Balance", "Vec<AccountId>"}, Documentation: []Text(nil)}, {Name: "ExternalTabled", Args: []Type(nil), Documentation: []Text(nil)}, {Name: "Started", Args: []Type{"ReferendumIndex", "VoteThreshold"}, Documentation: []Text(nil)}, {Name: "Passed", Args: []Type{"ReferendumIndex"}, Documentation: []Text(nil)}, {Name: "NotPassed", Args: []Type{"ReferendumIndex"}, Documentation: []Text(nil)}, {Name: "Cancelled", Args: []Type{"ReferendumIndex"}, Documentation: []Text(nil)}, {Name: "Executed", Args: []Type{"ReferendumIndex", "bool"}, Documentation: []Text(nil)}, {Name: "Delegated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text(nil)}, {Name: "Undelegated", Args: []Type{"AccountId"}, Documentation: []Text(nil)}, {Name: "Vetoed", Args: []Type{"AccountId", "Hash", "BlockNumber"}, Documentation: []Text(nil)}}, Constants: []ModuleConstantMetadataV6{{Name: "EnactmentPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x2f, 0xd, 0x0}, Documentation: []Text{" The minimum period of locking and the period between a proposal being approved and enacted.", "", " It should generally be a little more than the unstake period to ensure that", " voting stakers have an opportunity to remove themselves from the system in the case where", " they are on the losing side of a vote."}}, {Name: "LaunchPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) new public referenda are launched."}}, {Name: "VotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) to check for new votes."}}, {Name: "MinimumDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount to be used as a deposit for a public referendum proposal."}}, {Name: "EmergencyVotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x51, 0x1, 0x0}, Documentation: []Text{" Minimum voting period allowed for an emergency referendum."}}, {Name: "CooloffPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" Period in blocks where an external proposal may not be re-submitted after being vetoed."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Council", HasStorage: true, Storage: StorageMetadata{Prefix: "Instance1Collective", Items: []StorageFunctionMetadataV5{{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, {Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, {Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Votes<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, {Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, {Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_members", Args: []FunctionArgumentMetadata{{Name: "new_members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the collective's membership manually to `new_members`. Be nice to the chain and", " provide it pre-sorted.", "", " Requires root origin."}}, {Name: "execute", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective."}}, {Name: "propose", Args: []FunctionArgumentMetadata{{Name: "threshold", Type: "Compact<MemberCount>"}, {Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" # <weight>", " - Bounded storage reads and writes.", " - Argument `threshold` has bearing on weight.", " # </weight>"}}, {Name: "vote", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "T::Hash"}, {Name: "index", Type: "Compact<ProposalIndex>"}, {Name: "approve", Type: "bool"}}, Documentation: []Text{" # <weight>", " - Bounded storage read and writes.", " - Will be slightly heavier if the proposal is approved / disapproved after the vote.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`)."}}, {Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`)."}}, {Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold."}}, {Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold."}}, {Name: "Executed", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A motion was executed; `bool` is true if returned without error."}}, {Name: "MemberExecuted", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A single member did some action; `bool` is true if returned without error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "TechnicalCommittee", HasStorage: true, Storage: StorageMetadata{Prefix: "Instance2Collective", Items: []StorageFunctionMetadataV5{{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, {Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, {Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::Hash", Value: "Votes<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, {Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, {Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_members", Args: []FunctionArgumentMetadata{{Name: "new_members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the collective's membership manually to `new_members`. Be nice to the chain and", " provide it pre-sorted.", "", " Requires root origin."}}, {Name: "execute", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective."}}, {Name: "propose", Args: []FunctionArgumentMetadata{{Name: "threshold", Type: "Compact<MemberCount>"}, {Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}}, Documentation: []Text{" # <weight>", " - Bounded storage reads and writes.", " - Argument `threshold` has bearing on weight.", " # </weight>"}}, {Name: "vote", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "T::Hash"}, {Name: "index", Type: "Compact<ProposalIndex>"}, {Name: "approve", Type: "bool"}}, Documentation: []Text{" # <weight>", " - Bounded storage read and writes.", " - Will be slightly heavier if the proposal is approved / disapproved after the vote.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`)."}}, {Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`)."}}, {Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold."}}, {Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold."}}, {Name: "Executed", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A motion was executed; `bool` is true if returned without error."}}, {Name: "MemberExecuted", Args: []Type{"Hash", "bool"}, Documentation: []Text{" A single member did some action; `bool` is true if returned without error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Elections", HasStorage: true, Storage: StorageMetadata{Prefix: "Council", Items: []StorageFunctionMetadataV5{{Name: "PresentationDuration", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" How long to give each top candidate to present themselves after the vote ends."}}, {Name: "TermDuration", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" How long each position is active for."}}, {Name: "DesiredSeats", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of accounts that should constitute the collective."}}, {Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(T::AccountId, T::BlockNumber)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{"  The current membership. When there's a vote going on, this should still be used for", "  executive matters. The block number (second element in the tuple) is the block that", "  their position is active until (calculated by the sum of the block number when the", "  member was elected and their term duration)."}}, {Name: "VoteCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "VoteIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total number of vote rounds that have happened or are in progress."}}, {Name: "ApprovalsOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "(T::AccountId, SetIndex)", Value: "Vec<ApprovalFlag>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}, {Name: "RegisterInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "(VoteIndex, u32)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The vote index and list slot that the candidate `who` was registered or `None` if they", " are not currently registered."}}, {Name: "VoterInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "VoterInfo<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Basic information about a voter."}}, {Name: "Voters", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "SetIndex", Value: "Vec<Option<T::AccountId>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The present voter list (chunked and capped at [`VOTER_SET_SIZE`])."}}, {Name: "NextVoterSet", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SetIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" the next free set to store a voter in. This will keep growing."}}, {Name: "VoterCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SetIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current number of Voters."}}, {Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The present candidate list."}}, {Name: "CandidateCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current number of active candidates"}}, {Name: "NextFinalize", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "(T::BlockNumber, u32, Vec<T::AccountId>)", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The accounts holding the seats that will become free on the next tally."}}, {Name: "Leaderboard", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(BalanceOf<T>, T::AccountId)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Get the leaderboard if we're in the presentation phase. The first element is the weight", " of each entry; It may be the direct summed approval stakes, or a weighted version of it.", " Sorted from low to high."}}, {Name: "Proxy", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Who is able to vote for whom. Value is the fund-holding account, key is the", " vote-transaction-sending account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "set_approvals", Args: []FunctionArgumentMetadata{{Name: "votes", Type: "Vec<bool>"}, {Name: "index", Type: "Compact<VoteIndex>"}, {Name: "hint", Type: "SetIndex"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Set candidate approvals. Approval slots stay valid as long as candidates in those slots", " are registered.", "", " Locks `value` from the balance of `origin` indefinitely. Only [`retract_voter`] or", " [`reap_inactive_voter`] can unlock the balance.", "", " `hint` argument is interpreted differently based on:", " - if `origin` is setting approvals for the first time: The index will be checked for", "   being a valid _hole_ in the voter list.", "   - if the hint is correctly pointing to a hole, no fee is deducted from `origin`.", "   - Otherwise, the call will succeed but the index is ignored and simply a push to the", "     last chunk with free space happens. If the new push causes a new chunk to be", "     created, a fee indicated by [`VotingFee`] is deducted.", " - if `origin` is already a voter: the index __must__ be valid and point to the correct", "   position of the `origin` in the current voters list.", "", " Note that any trailing `false` votes in `votes` is ignored; In approval voting, not", " voting for a candidate and voting false, are equal.", "", " # <weight>", " - O(1).", " - Two extra DB entries, one DB change.", " - Argument `votes` is limited in length to number of candidates.", " # </weight>"}}, {Name: "proxy_set_approvals", Args: []FunctionArgumentMetadata{{Name: "votes", Type: "Vec<bool>"}, {Name: "index", Type: "Compact<VoteIndex>"}, {Name: "hint", Type: "SetIndex"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Set candidate approvals from a proxy. Approval slots stay valid as long as candidates in", " those slots are registered.", "", " # <weight>", " - Same as `set_approvals` with one additional storage read.", " # </weight>"}}, {Name: "reap_inactive_voter", Args: []FunctionArgumentMetadata{{Name: "reporter_index", Type: "Compact<u32>"}, {Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "who_index", Type: "Compact<u32>"}, {Name: "assumed_vote_index", Type: "Compact<VoteIndex>"}}, Documentation: []Text{" Remove a voter. For it not to be a bond-consuming no-op, all approved candidate indices", " must now be either unregistered or registered to a candidate that registered the slot", " after the voter gave their last approval set.", "", " Both indices must be provided as explained in [`voter_at`] function.", "", " May be called by anyone. Returns the voter deposit to `signed`.", "", " # <weight>", " - O(1).", " - Two fewer DB entries, one DB change.", " # </weight>"}}, {Name: "retract_voter", Args: []FunctionArgumentMetadata{{Name: "index", Type: "Compact<u32>"}}, Documentation: []Text{" Remove a voter. All votes are cancelled and the voter deposit is returned.", "", " The index must be provided as explained in [`voter_at`] function.", "", " Also removes the lock on the balance of the voter. See [`do_set_approvals()`].", "", " # <weight>", " - O(1).", " - Two fewer DB entries, one DB change.", " # </weight>"}}, {Name: "submit_candidacy", Args: []FunctionArgumentMetadata{{Name: "slot", Type: "Compact<u32>"}}, Documentation: []Text{" Submit oneself for candidacy.", "", " Account must have enough transferrable funds in it to pay the bond.", "", " NOTE: if `origin` has already assigned approvals via [`set_approvals`],", " it will NOT have any usable funds to pass candidacy bond and must first retract.", " Note that setting approvals will lock the entire balance of the voter until", " retraction or being reported.", "", " # <weight>", " - Independent of input.", " - Three DB changes.", " # </weight>"}}, {Name: "present_winner", Args: []FunctionArgumentMetadata{{Name: "candidate", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "total", Type: "Compact<BalanceOf<T>>"}, {Name: "index", Type: "Compact<VoteIndex>"}}, Documentation: []Text{" Claim that `candidate` is one of the top `carry_count + desired_seats` candidates. Only", " works iff the presentation period is active. `candidate` should have at least collected", " some non-zero `total` votes and `origin` must have enough funds to pay for a potential", " slash.", "", " # <weight>", " - O(voters) compute.", " - One DB change.", " # </weight>"}}, {Name: "set_desired_seats", Args: []FunctionArgumentMetadata{{Name: "count", Type: "Compact<u32>"}}, Documentation: []Text{" Set the desired member count; if lower than the current count, then seats will not be up", " election when they expire. If more, then a new vote will be started if one is not", " already in progress."}}, {Name: "remove_member", Args: []FunctionArgumentMetadata{{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove a particular member from the set. This is effective immediately.", "", " Note: A tally should happen instantly (if not already in a presentation", " period) to fill the seat if removal means that the desired members are not met."}}, {Name: "set_presentation_duration", Args: []FunctionArgumentMetadata{{Name: "count", Type: "Compact<T::BlockNumber>"}}, Documentation: []Text{" Set the presentation duration. If there is currently a vote being presented for, will", " invoke `finalize_vote`."}}, {Name: "set_term_duration", Args: []FunctionArgumentMetadata{{Name: "count", Type: "Compact<T::BlockNumber>"}}, Documentation: []Text{" Set the presentation duration. If there is current a vote being presented for, will", " invoke `finalize_vote`."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "VoterReaped", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" reaped voter, reaper"}}, {Name: "BadReaperSlashed", Args: []Type{"AccountId"}, Documentation: []Text{" slashed reaper"}}, {Name: "TallyStarted", Args: []Type{"u32"}, Documentation: []Text{" A tally (for approval votes of seat(s)) has started."}}, {Name: "TallyFinalized", Args: []Type{"Vec<AccountId>", "Vec<AccountId>"}, Documentation: []Text{" A tally (for approval votes of seat(s)) has ended (with one or more new members)."}}}, Constants: []ModuleConstantMetadataV6{{Name: "CandidacyBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" How much should be locked up in order to submit one's candidacy. A reasonable", " default value is 9."}}, {Name: "VotingBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" How much should be locked up in order to be able to submit votes."}}, {Name: "VotingFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xf4, 0x20, 0xe6, 0xb5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of fee paid upon each vote submission, unless if they submit a", " _hole_ index and replace it."}}, {Name: "PresentSlashPerVoter", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The punishment, per voter, if you provide an invalid presentation. A", " reasonable default value is 1."}}, {Name: "CarryCount", Type: "u32", Value: Bytes{0x6, 0x0, 0x0, 0x0}, Documentation: []Text{" How many runners-up should have their approvals persist until the next", " vote. A reasonable default value is 2."}}, {Name: "InactiveGracePeriod", Type: "VoteIndex", Value: Bytes{0x1, 0x0, 0x0, 0x0}, Documentation: []Text{" How many vote indices need to go by after a target voter's last vote before", " they can be reaped if their approvals are moot. A reasonable default value", " is 1."}}, {Name: "VotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0xe1, 0x0, 0x0}, Documentation: []Text{" How often (in blocks) to check for new votes. A reasonable default value", " is 1000."}}, {Name: "MinimumVotingLock", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum about that can be used as the locked value for voting."}}, {Name: "DecayRatio", Type: "u32", Value: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Decay factor of weight when being accumulated. It should typically be set to", " __at least__ `membership_size -1` to keep the collective secure.", " When set to `N`, it indicates `(1/N)^t` of staked is decayed at weight", " increment step `t`. 0 will result in no weight being added at all (normal", " approval voting). A reasonable default value is 24."}}, {Name: "VOTER_SET_SIZE", Type: "u32", Value: Bytes{0x40, 0x0, 0x0, 0x0}, Documentation: []Text{" The chunk size of the voter vector."}}, {Name: "APPROVAL_SET_SIZE", Type: "u32", Value: Bytes{0x8, 0x0, 0x0, 0x0}, Documentation: []Text{" The chunk size of the approval vector."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "TechnicalMembership", HasStorage: true, Storage: StorageMetadata{Prefix: "Instance1Membership", Items: []StorageFunctionMetadataV5{{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current membership, stored as an ordered Vec."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "add_member", Args: []FunctionArgumentMetadata{{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Add a member `who` to the set.", "", " May only be called from `AddOrigin` or root."}}, {Name: "remove_member", Args: []FunctionArgumentMetadata{{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Remove a member `who` from the set.", "", " May only be called from `RemoveOrigin` or root."}}, {Name: "swap_member", Args: []FunctionArgumentMetadata{{Name: "remove", Type: "T::AccountId"}, {Name: "add", Type: "T::AccountId"}}, Documentation: []Text{" Swap out one member `remove` for another `add`.", "", " May only be called from `SwapOrigin` or root."}}, {Name: "reset_members", Args: []FunctionArgumentMetadata{{Name: "members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Change the membership to a new set, disregarding the existing membership. Be nice and", " pass `members` pre-sorted.", "", " May only be called from `ResetOrigin` or root."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "MemberAdded", Args: []Type(nil), Documentation: []Text{" The given member was added; see the transaction for who."}}, {Name: "MemberRemoved", Args: []Type(nil), Documentation: []Text{" The given member was removed; see the transaction for who."}}, {Name: "MembersSwapped", Args: []Type(nil), Documentation: []Text{" Two members were swapped; see the transaction for who."}}, {Name: "MembersReset", Args: []Type(nil), Documentation: []Text{" The membership was reset; see the transaction for who the new set is."}}, {Name: "Dummy", Args: []Type{"rstd::marker::PhantomData<(AccountId, Event)>"}, Documentation: []Text{" Phantom member, never used."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "FinalityTracker", HasStorage: false, Storage: StorageMetadata{Prefix: "", Items: []StorageFunctionMetadataV5(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "final_hint", Args: []FunctionArgumentMetadata{{Name: "hint", Type: "Compact<T::BlockNumber>"}}, Documentation: []Text{" Hint that the author of this block thinks the best finalized", " block is the given number."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{{Name: "WindowSize", Type: "T::BlockNumber", Value: Bytes{0x65, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of recent samples to keep from this chain. Default is 101."}}, {Name: "ReportLatency", Type: "T::BlockNumber", Value: Bytes{0xe8, 0x3, 0x0, 0x0}, Documentation: []Text{" The delay after which point things become suspicious. Default is 1000."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Grandpa", HasStorage: true, Storage: StorageMetadata{Prefix: "GrandpaFinality", Items: []StorageFunctionMetadataV5{{Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<(AuthorityId, AuthorityWeight)>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current authority set."}}, {Name: "State", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "StoredState<T::BlockNumber>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" State of the current authority set."}}, {Name: "PendingChange", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "StoredPendingChange<T::BlockNumber>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending change: (signaled at, scheduled change)."}}, {Name: "NextForced", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" next block number where we can force a change."}}, {Name: "Stalled", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "(T::BlockNumber, T::BlockNumber)", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" `true` if we are currently stalled."}}, {Name: "CurrentSetId", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "SetId", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of changes (both in terms of keys and underlying economic responsibilities)", " in the \"set\" of Grandpa validators from genesis."}}, {Name: "SetIdSession", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "SetId", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from grandpa set ID to the index of the *most recent* session for which its members were responsible."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "report_misbehavior", Args: []FunctionArgumentMetadata{{Name: "_report", Type: "Vec<u8>"}}, Documentation: []Text{" Report some misbehavior."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "NewAuthorities", Args: []Type{"Vec<(AuthorityId, AuthorityWeight)>"}, Documentation: []Text{" New authority set has been applied."}}, {Name: "Paused", Args: []Type(nil), Documentation: []Text{" Current authority set has been paused."}}, {Name: "Resumed", Args: []Type(nil), Documentation: []Text{" Current authority set has been resumed."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Treasury", HasStorage: true, Storage: StorageMetadata{Prefix: "Treasury", Items: []StorageFunctionMetadataV5{{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "ProposalIndex", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of proposals that have been made."}}, {Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ProposalIndex", Value: "Proposal<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposals that have been made."}}, {Name: "Approvals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<ProposalIndex>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposal indices that have been approved but not yet awarded."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "propose_spend", Args: []FunctionArgumentMetadata{{Name: "value", Type: "Compact<BalanceOf<T>>"}, {Name: "beneficiary", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Put forward a suggestion for spending. A deposit proportional to the value", " is reserved and slashed if the proposal is rejected. It is returned once the", " proposal is awarded.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change, one extra DB entry.", " # </weight>"}}, {Name: "reject_proposal", Args: []FunctionArgumentMetadata{{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Reject a proposed spend. The original deposit will be slashed.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB clear.", " # </weight>"}}, {Name: "approve_proposal", Args: []FunctionArgumentMetadata{{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Approve a proposal. At a later time, the proposal will be allocated to the beneficiary", " and the original deposit will be returned.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Proposed", Args: []Type{"ProposalIndex"}, Documentation: []Text{" New proposal."}}, {Name: "Spending", Args: []Type{"Balance"}, Documentation: []Text{" We have ended a spend period and will now allocate funds."}}, {Name: "Awarded", Args: []Type{"ProposalIndex", "Balance", "AccountId"}, Documentation: []Text{" Some funds have been allocated."}}, {Name: "Burnt", Args: []Type{"Balance"}, Documentation: []Text{" Some of our funds have been burnt."}}, {Name: "Rollover", Args: []Type{"Balance"}, Documentation: []Text{" Spending has finished; this is the amount that rolls over until next spend."}}}, Constants: []ModuleConstantMetadataV6{{Name: "ProposalBond", Type: "Permill", Value: Bytes{0x50, 0xc3, 0x0, 0x0}, Documentation: []Text{" Fraction of a proposal's value that should be bonded in order to place the proposal.", " An accepted proposal gets these back. A rejected proposal does not."}}, {Name: "ProposalBondMinimum", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum amount of funds that should be placed in a deposit for making a proposal."}}, {Name: "SpendPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" Period between successive spends."}}, {Name: "Burn", Type: "Permill", Value: Bytes{0x20, 0xa1, 0x7, 0x0}, Documentation: []Text{" Percentage of spare funds (if any) that are burnt per spend period."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Contracts", HasStorage: true, Storage: StorageMetadata{Prefix: "Contract", Items: []StorageFunctionMetadataV5{{Name: "GasSpent", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Gas", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Gas spent so far in this block."}}, {Name: "CurrentSchedule", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Schedule", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x87, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" Current cost schedule for contracts."}}, {Name: "PristineCode", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "CodeHash<T>", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from an original code hash to the original code, untouched by instrumentation."}}, {Name: "CodeStorage", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "CodeHash<T>", Value: "wasm::PrefabWasmModule", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping between an original code hash and instrumented wasm code, ready for execution."}}, {Name: "AccountCounter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The subtrie counter."}}, {Name: "ContractInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "T::AccountId", Value: "ContractInfo<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The code associated with a given account."}}, {Name: "GasPrice", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The price of one unit of gas."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "update_schedule", Args: []FunctionArgumentMetadata{{Name: "schedule", Type: "Schedule"}}, Documentation: []Text{" Updates the schedule for metering contracts.", "", " The schedule must have a greater version than the stored schedule."}}, {Name: "put_code", Args: []FunctionArgumentMetadata{{Name: "gas_limit", Type: "Compact<Gas>"}, {Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Stores the given binary Wasm code into the chain's storage and returns its `codehash`.", " You can instantiate contracts only with stored code."}}, {Name: "call", Args: []FunctionArgumentMetadata{{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "value", Type: "Compact<BalanceOf<T>>"}, {Name: "gas_limit", Type: "Compact<Gas>"}, {Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Makes a call to an account, optionally transferring some balance.", "", " * If the account is a smart-contract account, the associated code will be", " executed and any value will be transferred.", " * If the account is a regular account, any value will be transferred.", " * If no account exists and the call value is not less than `existential_deposit`,", " a regular account will be created and any value will be transferred."}}, {Name: "instantiate", Args: []FunctionArgumentMetadata{{Name: "endowment", Type: "Compact<BalanceOf<T>>"}, {Name: "gas_limit", Type: "Compact<Gas>"}, {Name: "code_hash", Type: "CodeHash<T>"}, {Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Instantiates a new contract from the `codehash` generated by `put_code`, optionally transferring some balance.", "", " Instantiation is executed as follows:", "", " - The destination address is computed based on the sender and hash of the code.", " - The smart-contract account is created at the computed address.", " - The `ctor_code` is executed in the context of the newly-created account. Buffer returned", "   after the execution is saved as the `code` of the account. That code will be invoked", "   upon any call received by this account.", " - The contract is initialized."}}, {Name: "claim_surcharge", Args: []FunctionArgumentMetadata{{Name: "dest", Type: "T::AccountId"}, {Name: "aux_sender", Type: "Option<T::AccountId>"}}, Documentation: []Text{" Allows block producers to claim a small reward for evicting a contract. If a block producer", " fails to do so, a regular users will be allowed to claim the reward.", "", " If contract is not evicted as a result of this call, no actions are taken and", " the sender is not eligible for the reward."}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" Transfer happened `from` to `to` with given `value` as part of a `call` or `instantiate`."}}, {Name: "Instantiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Contract deployed by address at the specified address."}}, {Name: "CodeStored", Args: []Type{"Hash"}, Documentation: []Text{" Code with the specified hash has been stored."}}, {Name: "ScheduleUpdated", Args: []Type{"u32"}, Documentation: []Text{" Triggered when the current schedule is updated."}}, {Name: "Dispatched", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A call was dispatched from the given account. The bool signals whether it was", " successful execution or not."}}, {Name: "Contract", Args: []Type{"AccountId", "Vec<u8>"}, Documentation: []Text{" An event from contract of account."}}}, Constants: []ModuleConstantMetadataV6{{Name: "SignedClaimHandicap", Type: "T::BlockNumber", Value: Bytes{0x2, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of block delay an extrinsic claim surcharge has.", "", " When claim surcharge is called by an extrinsic the rent is checked", " for current_block - delay"}}, {Name: "TombstoneDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to generate a tombstone."}}, {Name: "StorageSizeOffset", Type: "u32", Value: Bytes{0x8, 0x0, 0x0, 0x0}, Documentation: []Text{" Size of a contract at the time of instantiaion. This is a simple way to ensure that", " empty contracts eventually gets deleted."}}, {Name: "RentByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Price of a byte of storage per one block interval. Should be greater than 0."}}, {Name: "RentDepositOffset", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0x8a, 0x5d, 0x78, 0x45, 0x63, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of funds a contract should deposit in order to offset", " the cost of one byte.", "", " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,", " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.", " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,", " then it would pay 500 BU/day."}}, {Name: "SurchargeReward", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xa1, 0xa7, 0x6b, 0x4a, 0x35, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Reward that is received by the party whose touch has led", " to removal of a contract."}}, {Name: "TransferFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to make a transfer."}}, {Name: "CreationFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to create an account."}}, {Name: "TransactionBaseFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the base."}}, {Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}, {Name: "ContractFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee required to instantiate a contract instance. A reasonable default value", " is 21."}}, {Name: "CallBaseFee", Type: "Gas", Value: Bytes{0xe8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base fee charged for calling into a contract. A reasonable default", " value is 135."}}, {Name: "InstantiateBaseFee", Type: "Gas", Value: Bytes{0xe8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base fee charged for instantiating a contract. A reasonable default value", " is 175."}}, {Name: "MaxDepth", Type: "u32", Value: Bytes{0x0, 0x4, 0x0, 0x0}, Documentation: []Text{" The maximum nesting level of a call/instantiate stack. A reasonable default", " value is 100."}}, {Name: "MaxValueSize", Type: "u32", Value: Bytes{0x0, 0x40, 0x0, 0x0}, Documentation: []Text{" The maximum size of a storage value in bytes. A reasonable default is 16 KiB."}}, {Name: "BlockGasLimit", Type: "Gas", Value: Bytes{0x80, 0x96, 0x98, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum amount of gas that could be expended per block. A reasonable", " default value is 10_000_000."}}}, Errors: []ErrorMetadataV8(nil)}, {Name: "Sudo", HasStorage: true, Storage: StorageMetadata{Prefix: "Sudo", Items: []StorageFunctionMetadataV5{{Name: "Key", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The `AccountId` of the sudo key."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "sudo", Args: []FunctionArgumentMetadata{{Name: "proposal", Type: "Box<T::Proposal>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Root` origin.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Unknown weight of derivative `proposal` execution.", " # </weight>"}}, {Name: "set_key", Args: []FunctionArgumentMetadata{{Name: "new", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}, {Name: "sudo_as", Args: []FunctionArgumentMetadata{{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, {Name: "proposal", Type: "Box<T::Proposal>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Signed` origin from", " a given account.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Unknown weight of derivative `proposal` execution.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{{Name: "Sudid", Args: []Type{"bool"}, Documentation: []Text{" A sudo just took place."}}, {Name: "KeyChanged", Args: []Type{"AccountId"}, Documentation: []Text{" The sudoer just switched identity; the old key is supplied."}}, {Name: "SudoAsDone", Args: []Type{"bool"}, Documentation: []Text{" A sudo just took place."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "ImOnline", HasStorage: true, Storage: StorageMetadata{Prefix: "ImOnline", Items: []StorageFunctionMetadataV5{{Name: "GossipAt", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The block number when we should gossip."}}, {Name: "Keys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::AuthorityId>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of keys that may issue a heartbeat."}}, {Name: "ReceivedHeartbeats", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "SessionIndex", Key2: "AuthIndex", Value: "Vec<u8>", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" For each session index we keep a mapping of `AuthorityId`", " to `offchain::OpaqueNetworkState`."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{{Name: "heartbeat", Args: []FunctionArgumentMetadata{{Name: "heartbeat", Type: "Heartbeat<T::BlockNumber>"}, {Name: "signature", Type: "<T::AuthorityId as RuntimeAppPublic>::Signature"}}, Documentation: []Text(nil)}}, HasEvents: true, Events: []EventMetadataV4{{Name: "HeartbeatReceived", Args: []Type{"AuthorityId"}, Documentation: []Text{" A new heartbeat was received from `AuthorityId`"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "AuthorityDiscovery", HasStorage: false, Storage: StorageMetadata{Prefix: "", Items: []StorageFunctionMetadataV5(nil)}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "Offences", HasStorage: true, Storage: StorageMetadata{Prefix: "Offences", Items: []StorageFunctionMetadataV5{{Name: "Reports", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "ReportIdOf<T>", Value: "OffenceDetails<T::AccountId, T::IdentificationTuple>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The primary structure that holds all offence records keyed by report identifiers."}}, {Name: "ConcurrentReportsIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "Kind", Key2: "OpaqueTimeSlot", Value: "Vec<ReportIdOf<T>>", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A vector of reports of the same kind that happened at the same time slot."}}, {Name: "ReportsByKindIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "Kind", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Enumerates all reports of a kind along with the time they happened.", "", " All reports are sorted by the time of offence.", "", " Note that the actual type of this mapping is `Vec<u8>`, this is because values of", " different types are not supported at the moment so we are doing the manual serialization."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: true, Events: []EventMetadataV4{{Name: "Offence", Args: []Type{"Kind", "OpaqueTimeSlot"}, Documentation: []Text{" There is an offence reported of the given `kind` happened at the `session_index` and", " (kind-specific) time slot. This event is not deposited for duplicate slashes."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, {Name: "RandomnessCollectiveFlip", HasStorage: true, Storage: StorageMetadata{Prefix: "RandomnessCollectiveFlip", Items: []StorageFunctionMetadataV5{{Name: "RandomMaterial", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV5{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV4{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV5{Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasher{IsBlake2_128: false, IsBlake2_256: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Series of block headers from the last 81 blocks that acts as random seed material. This", " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of", " the oldest hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}}}} //nolint:lll,dupl
